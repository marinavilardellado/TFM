---
title: "Final Report"
author: "Marina Vilardell"
date: "2023-08-16"
output: 
  BiocStyle::html_document:
    number_sections: true
    toc_float: yes
---

In this report you will find all the steps performed to analyze microarray data coming from healthy and cancer affected patients with BRCA1/2 mutated and no-mutated. The array used is the GeneChip Human Genome U133 Plus 2.0. 

# Working directory and libraries

Set working directory and the libraries needed to load the files:

```{r,message=FALSE,warning=FALSE}
wd<-setwd("C:/Users/MARINA/Documents/MASTER/TFM/Data_analysis")

# wd of the Cel files
cel.wd<-'../Initial_analysis/CEl_files'

library(readxl)
library(affy)
library(limma)
library(glmnet)
library(immunedeconv)
library(tidyverse)
library(ggplot2)
library(DT)
```

# Load and prepare the data

Load the file that contains the phenodata (treatment, mutation, Disease ...) and the CEL files. Then, check that the phenodata and CEL files are in the same order. 
```{r,message=FALSE,warning=FALSE}
#Load pheno data
pdata<-read.csv2('../Initial_analysis/phenodata.csv',header=TRUE)

#change the wd to where the cel files are
setwd(file.path(wd,cel.wd))

# get eligible data ("CEL" files)
celFiles = list.files(file.path(wd,cel.wd), pattern = "CEL")

# --- Pdata and cel files have to be in the same order ---
pdata$ID<-gsub(' ','_',pdata$ID)
order<-pdata$ID
factor_celfiles<-factor(celFiles,levels = order)
celFiles_ordered<-celFiles[order(factor_celfiles)]

#check the order
identical(celFiles_ordered,pdata$ID)#same order
head(cbind(celFiles_ordered, pdata))

```


## Read CEL files

Once the data is loaded, we will read the CEL files with the ReadAffy() function. 

```{r,read cel files,warning=FALSE}
# change row names of pdata
rownames(pdata)<-pdata$ID
pdata<-pdata[,-1]

# Read CEL files 
setwd(file.path(wd,cel.wd))
brca_data <- ReadAffy(filenames = as.vector(rownames(pdata)), phenoData = pdata)

brca_data
```

Brca_data is an AffyBatch Object that contains all 106 samples and 54675 probe sets.

## Data exploration 

We will explore the data to help clarify what we have now. 

```{r}
# --- matrix of intensities for each probe ---
head(exprs(brca_data))[,1:6]
dim(exprs(brca_data))
```

The matrix of intensities contains raw signal, not normalized. We have 106 samples and 1354896 probes. Now let's get information regarding the phenodata. 

The following tables will summarize the number of individuals for each condition: 
```{r}
# --- Get phenoData ---
head(pData(brca_data))

# Number of healthy and Afected samples
table(pData(brca_data)$Disease)

# Number of samples for each phenotype
table(pData(brca_data)$Phenotype)

# Number of samples non-radiated and radiated
table(pData(brca_data)$Treatment)

```


# Quality control

In the quality control step, we will check the distributions of the data to detect possible outliers and remove them from the study. 


## Image assessment

We first start checking the images that are generated by the scan. The intensities are measuring the amount of expression in each probe.

```{r}
# --- array images ----
#image(brca_data)

```
![](C:/Users/MARINA/Documents/MASTER/TFM/Initial_analysis/image_17.jpg)

The images of the scan were generated for all the 106 samples, but just the image for sample 17 is showed. The rest of the images can be found in the Supplementary section. 

In SG-18.CEL, SG-107.CEL and SG-121.CEL there are little marks, but they were not significant enough to remove the arrays.


## Data quality plots

Now we will check the quality of the data by producing some intensity density plots, intensity box plots, MAplots and RLE and NUSE box plots.

```{r}
# BOXPLOT
colors<-palette('Set2')
boxplot(brca_data,col=colors,las=3,cex.axis=0.3, main='Boxplot of intensities',ylab='Intensity level',xlab='samples') 
```

In the boxplot we see that all the samples intensity medians are quite in the same range. Obviously there are samples with higher expression and other with lower, but it is fine to see heterogeneity. No outliers are detected. The boxplots of the three samples SG-18.CEL, SG-107.CEL and SG-121.CEL seem to have a normal distribution such as other samples.


```{r}
# HISTOGRAM

hist(brca_data,col=colors, main='Histogram of intensities',ylab='Density',xlab='Log itensity')
```

This histogram shows the distribution of the intensities. Sample SG-81.CEL seems to have a little bit of more intensities than the others, but it is not considered an outlier. 

```{r}
# MA plot
# MAplot(brca_data) #each array against a pseudo-median of all other arrays
```

![](C:/Users/MARINA/Documents/MASTER/TFM/Initial_analysis/MA_image_17.jpg)

In this MA plot, we are comparing the sample 17 with the reference, and we are measuring the differences in the intensity of the probes. As the red line is above the blue, that means that this sample has higher intensity than the median. The other plots can be found in the Supplementary section. 

```{r,fig.keep='first',message=FALSE}
# ----- RLE plots --------
library(affyPLM)
fitmodel<-fitPLM(brca_data) #fit a model
RLE(fitmodel,las=3,cex.axis=0.3,col=colors)
```

Again, we study the probes while comparing them to the other probes in the rest of the arrays. We compute the expression of one probe and compare to the expression media of the same probes in the other arrays. Once we have fit the model, the RLE plot is generated and all the medians are close to 0, that is what we expect.

```{r,fig.keep='first'}
# ------- NUSE plots -----------
NUSE(fitmodel,las=3,cex.axis=0.3,col=colors,ylim=c(0.95,1.1))
```

We also study the Normalized Unscaled Standard Errors (NUSE plots), in which we expect to see the median close to 1 for all the samples. There is a little bit of dispersion, but all the samples are really close to 1. 

In conclusion, there is a good quality of the samples and no array is removed from the study. 


# Normalization

After the quality control, we need to perform a normalization step, applying the Robust Multichip Average (RMA) approach.

```{r, message=FALSE}
# Normalization
brca.rma <- affy::rma(brca_data)#Normalization
dim(brca.rma)
```
After normalization we have 54675 summarized probesets. 

```{r}
# Boxplot of intensities
boxplot(exprs(brca.rma),las=3,cex.axis=0.3,outline=FALSE) 
abline(h=median(exprs(brca.rma)),col="blue")
```

The boxplot on the normalized intensities is performed and the distribution is similar and homogeneous in all of the samples.

# Sample aggregation

To see how samples aggregate, hierarchical clustering and PCA is performed. The purpose is to see if samples aggregate by their condition, or they don't. 
We will see if samples aggregate by disease (Cancer affected versus healthy), and by phenotype (BRCA1.AF/BRCA1.SA/BRCA2.AF/BRCA2.SA/NOMUT.SA/NOMUT/AF).

```{r,warning=FALSE,message=FALSE}
library(dendextend)

# --- Get matrix of intensities ---
expression_all<-exprs(brca.rma)
```

We will use different methods to check if the clusterization is the same or similar.

## Sample aggregation by disease

```{r}
## --- Euclidean distance,method ward.D2 ---
hcwd2_all <- hclust(dist(t(expression_all)),method="ward.D2")

# Build dendrogram object from hclust results
dend_wd2_all <- as.dendrogram(hcwd2_all)
order_wd2_all<-unlist(dend_wd2_all)

## sample aggregation by disease
condition<-c(pData(brca.rma)$Disease)
condition<-condition[order_wd2_all] 
colors<-palette('Dark2') # set a color palette
names(colors)<-levels(factor(condition))
condition_colors <- colors[condition]

dend_wd2_all %>% set("labels_col", condition_colors) %>% 
  set("labels_cex", 0.7) %>% # Change size
  plot(main = "Dendogram") # plot
legend("topright", legend = unique(condition),fill = colors)


## --- Correlation based distance, average method ---
clust.cor.average_all<- hclust(as.dist(1-cor(expression_all)),method="average")
dendcbd_all<-as.dendrogram(clust.cor.average_all)
order_cbd_all<-unlist(dendcbd_all)
condition<-c(pData(brca.rma)$Disease)
condition<-condition[order_cbd_all]
condition<-relevel(factor(condition),'SA')
condition_colors2 <- colors[as.numeric(factor(condition))]

dendcbd_all %>% set("labels_col", condition_colors2) %>% # change color
  set("labels_cex", 0.7) %>% # Change size
  plot(main = "Dendrogram") # plot
legend("topright", legend = unique(condition),fill = colors)
```

Samples do not aggregate well by disease condition.


## Sample aggregation by phenotype

```{r}
# --- Euclidean distance, method ward.D2 ---
hcwd2_all <- hclust(dist(t(expression_all)),method="ward.D2")
dendwd2_all <- as.dendrogram(hcwd2_all)
orderwd2_all<-unlist(dendwd2_all)

condition<-c(pData(brca.rma)$Phenotype)
condition<-condition[orderwd2_all]
condition<-factor(condition,c('BRCA2.SA','BRCA1.AF','BRCA2.AF','NOMUT.AF','NOMUT.SA','BRCA1.SA'))
condition_colors <- colors[as.numeric(factor(condition))]

dendwd2_all %>% set("labels_col", condition_colors) %>% # change color
  set("labels_cex", 0.7) %>% # Change size
  plot(main = "Dendrogram") # plot
legend("topright", legend = unique(condition), fill = colors)
```

No aggregation of samples based on their phenotype condition. 

## PCA

As there is a very large number of variables (probe sets), we will use the principal component analysis (PCA) to reduce the dimensionality of the data.

```{r}
summary(pca.filt <- prcomp(t(expression_all), scale=T ))
```

The first principal component explains just 11,6% of the variability of the data, the second PC, around 8,5%, and the third PC 5,7%, which is very few variability. 

```{r,message=FALSE}
# --- PCA by phenotype ---
library(factoextra)
fviz_pca_ind(pca.filt,col.ind = pData(brca.rma)$Phenotype,addEllipses = TRUE,geom.ind = 'point')

# ---PCA by disease ---
fviz_pca_ind(pca.filt,col.ind = pData(brca.rma)$Disease,addEllipses = TRUE,geom.ind = 'point')
```

With the first two PC around 20% of the variability of the data is explained, which is very low. 

The ellipses overlap each other, which implies similar gene expression profiles between each condition.

To sum up this part, after performing hierarchical clustering and PCA, there is no good aggregation of the samples, and there is not a specific gene profile for each condition. 


# Annotation 

In this step, we will assign the identifiers to known annotations. To do this, we will need the corresponding R annotation package to the microarray technology that was used. This R package corresponds to the Affymetrix HG-U133_Plus_2 Array annotation data (chip hgu133plus2). The version of this package is the 3.13.0.

As there are different probe sets in a microarray that correpond to the same gene, we will use the probe ID plus the gene symbol as the row name of the expression matrix, by now. There might be the presence of Not Available (NA) annotations for certain probe sets, and these probes will be removed from the experiment. 


```{r,message=FALSE}
library(annotate)
library(hgu133plus2.db)

# --- Annotation ---
data<-rownames(exprs(brca.rma))
symbol_data <-mget(data, env = hgu133plus2SYMBOL)

annotated_data<-paste(data,symbol_data,sep = '_')
rownames(brca.rma)<-annotated_data


# --- Remove NA in the annotation ---
expression_brca<-exprs(brca.rma)
pos_all_NA<-grep('_NA$',rownames(expression_brca))
brca.rma_noNA<-brca.rma[-pos_all_NA,]

dim(brca.rma)
dim(brca.rma_noNA) # remove 11574 NA
length(pos_all_NA)

```

We can see that when using this R package, there are 11574 probes sets that are not annotated (NA). In order to reduce the number of NA, and to try to get the maximum information as possible, we will use the annotation file provided by the microarray manufacturer, which is Thermo Fisher. This annotation file contains information for every probe set, such as the gene symbol and we will check whether the NA are indeed NA in the Thermo fhisher file or if we get some annotated genes for those non annotated probe sets using the R package. 


## Check NA probe sets

```{r,message==FALSE}
library(dplyr)
library(readr)
HG_U133_Plus_2_na36_annot <- read_csv("HG-U133_Plus_2.na36.annot.csv", skip = 25)
head(HG_U133_Plus_2_na36_annot)[1:5,c(1,14:17)]

# Get NA annotated probe names (of hgu133plus2.db R package)
NA_values<-grep('_NA$',rownames(expression_brca),value=TRUE)# probe set names of the no annotated 
NA_values<-gsub('_NA','',NA_values)

#select the gene names in the thermo-fisher annotation file of the R package NA values: 
pos_NA<-which(HG_U133_Plus_2_na36_annot$`Probe Set ID` %in% NA_values)
HG_na<-HG_U133_Plus_2_na36_annot[pos_NA,]

#Select only the columns Probe set ID and the Gene symbol
HG_gene_symbol_NA<-as.data.frame(HG_na[,c("Probe Set ID", "Gene Symbol")])

head(NA_values)# probe set names of the no annotated with R package 
head(HG_gene_symbol_NA) # Probe set ID + gene symbol of only those probe sets that were no annotated previously
```


This data frame contains the probe sets and the gene symbol of the thermo fisher file that were not annotated using the R package. As it is seen there are some probes that keep with no annotation (---), and others that have indeed an annotation.

```{r}
#need to order the HG data frame based on the order of the NA_values order
index <- match(NA_values, HG_gene_symbol_NA$`Probe Set ID`)
HG_gene_symbol_NA_ordered <- HG_gene_symbol_NA[index, ]

identical(NA_values,HG_gene_symbol_NA_ordered$`Probe Set ID`)

# Probe sets that are not annotated neither using R package and the thermo fisher file
dim(HG_gene_symbol_NA_ordered[HG_gene_symbol_NA_ordered$`Gene Symbol`=='---',])

# Probe sets that are being annotated when using the thermo fisher file and were not annotated with the R package
HG_gene_name_ofNAexpressionset<-HG_gene_symbol_NA_ordered[HG_gene_symbol_NA_ordered$`Gene Symbol`!='---',]
dim(HG_gene_name_ofNAexpressionset)
head(HG_gene_name_ofNAexpressionset)
#2184 probe sets with annotation that have to be substituted in the expressionSet object
```

Of the 11574 no annotated probes using the R package 'hgu133plus2.db', there are 9390 probe sets that will remain no annotated, whereas 2184 probe sets have an annotation. 

In microarrays, a probe set can have more than one annotated gene associated with it, as it seen in the above table. Since each probe set contains multiple individual probes with varying sequences, they can target a region that is shared by some genes or transcripts isoforms. This occurs when there are regions of sequence similarity or overlap among different genes, so, the probe set can hybridize with multiple transcripts or genes. 

To deal with this, we will get the first gene symbol identification for those probes that have multiple gene symbols annotated. 
```{r}
# ----  Get the first Gene Symbol ----
# Create an empty vector to store the first values
split_values <- character(length(HG_gene_name_ofNAexpressionset$`Gene Symbol`))
for (i in 1:nrow(HG_gene_name_ofNAexpressionset)){
  split_values[i] <- strsplit(HG_gene_name_ofNAexpressionset$`Gene Symbol`, " /// ")[[i]][1]
  }

HG_gene_name_ofNAexpressionset$Unique_Gene_symbol<-unlist(split_values)
```

Once we have a unique gene symbol for each probe set, we have to substitute them for the NA symbol in the expression matrix.

```{r}
# Get the gene names and substitute them instead of NA
change_NA_values<-intersect(NA_values,HG_gene_name_ofNAexpressionset$`Probe Set ID`)
new_probesets_anotated<-paste(change_NA_values,HG_gene_name_ofNAexpressionset$Unique_Gene_symbol,sep = '_')

pos_inthematrix_that_need_tobechange<-which(data %in% change_NA_values)

#Subset the expression matrix of those probe sets its name has to be changed
matrix_subset <- as.matrix(expression_brca[pos_inthematrix_that_need_tobechange, ])#this contains the intensity values of the probes sets that its gene symbol has been change
rownames(matrix_subset) <- new_probesets_anotated

expression_brca[pos_inthematrix_that_need_tobechange,][1:5,1:5]
head(matrix_subset)[1:5,1:5]
```

We can see that the probe set names that were annotated in the thermo fisher file and didn't in the R package, have been changed. 

Now, we want to know how many probe sets are annotated in both R package and Thermo fisher file.

```{r}
# Get the probe sets that were annotated using the R package.
probsets_well_annotated_R_pack<-rownames(exprs(brca.rma_noNA))

# Split the vector into probe names and gene names using the last underscore
split_probesets <- strsplit(probsets_well_annotated_R_pack, "_(?!.*_)", perl = TRUE)

# Extract the probe set names and the gene names and create a data frame
probe_names<-NULL
gene_names<-NULL
for (i in 1:length(split_probesets)){
  probe_names[i]<-split_probesets[[i]][1]
  gene_names[i]<-split_probesets[[i]][2]
 }
df_annotated_probes_R_pack <- data.frame(ProbeName = probe_names, GeneName = gene_names)
head(df_annotated_probes_R_pack)

# To know the position of the probes that are annotated in both data frames.
x<-which(HG_U133_Plus_2_na36_annot$`Probe Set ID`%in%df_annotated_probes_R_pack$ProbeName)
df_TF<-HG_U133_Plus_2_na36_annot[x,c("Probe Set ID", "Gene Symbol")]

#Check the probe set names are in the same order than the df of thermo.fisher
identical(df_annotated_probes_R_pack$ProbeName,df_TF$`Probe Set ID`)

index <- match(df_annotated_probes_R_pack$ProbeName, df_TF$`Probe Set ID`)
df_TF_or <- df_TF[index, ]

identical(df_annotated_probes_R_pack$ProbeName,df_TF_or$`Probe Set ID`)

# How many of the annotated probes sets using the R package, are no annotated in the TF file
dim(df_TF_or[df_TF_or$`Gene Symbol`=='---',])
# There are 229 probe sets that were annotated using the R package and are not annotated in the TF file
dim(df_TF_or[df_TF_or$`Gene Symbol`!='---',])
# There are 42872 probe sets that were annotated using the R package, and keep being annotated in the TF file

```

There are 229 probe sets that were annotated when using the R package, and are no annotated in the thermo fisher file, and 42872 probe sets that are annotated in the R package and keep being annotated in the thermo fisher file. 
This results are summarized in the following confusion matrix.

```{r}
# --- Confusion matrix ---
confusion_matrix<-data.frame(Annotated_TF_file=c(dim(df_TF_or[df_TF_or$`Gene Symbol`!='---',])[1],dim(HG_gene_name_ofNAexpressionset)[1]               ),No_annotated_TF_file=c(dim(df_TF_or[df_TF_or$`Gene Symbol`=='---',])[1],dim(HG_gene_symbol_NA_ordered[HG_gene_symbol_NA_ordered$`Gene Symbol`=='---',])[1]),row.names = c('Annotated_R_package','No_annotated_R_package'))

confusion_matrix

```

It is important to check whether the probes that are annotated in both R package and in the thermo fisher file, have the same gene symbol. To do so, we will calculate the percentage of the gene symbols that are identical.  

```{r}
# Select the 42872 probe sets.
df_annotated2_TF<-df_TF_or[df_TF_or$`Gene Symbol`!='---',]
poss<-which(df_annotated_probes_R_pack$ProbeName %in% df_annotated2_TF$`Probe Set ID`)
df_annotated_probes_R2<-df_annotated_probes_R_pack[poss,]

# The probe sets need to be in the same order, otherwise, we will get a false percentage
identical(df_annotated2_TF$`Probe Set ID`,df_annotated_probes_R2$ProbeName)
rownames(df_annotated_probes_R2)<-1:nrow(df_annotated_probes_R2)

# Select the probe sets that have more than one gene symbol annotation, and continue with the first annotation.
pos_multiplegenes<-grep('///',df_annotated2_TF$`Gene Symbol`)
df_TF_multiplegenes<-df_annotated2_TF[pos_multiplegenes,]

split_values2 <- NULL
for (i in 1:nrow(df_TF_multiplegenes)){
  split_values2[i] <- strsplit(df_TF_multiplegenes$`Gene Symbol`, " /// ")[[i]][1]
  }
df_TF_multiplegenes$Unique_Gene_symbol<-unlist(split_values2)

# Create a data frame with the probe name and with only one Gene symbol annotation.
merged_df <- merge(df_annotated2_TF, df_TF_multiplegenes, by = "Probe Set ID", all.x = TRUE)
merged_df<-merged_df[,-3]
# Update the Gene column with the values from the second data frame
merged_df$Gene <- ifelse(is.na(merged_df$Unique_Gene_symbol), merged_df$`Gene Symbol.x`, merged_df$Unique_Gene_symbol)
merged_df <- merged_df[, c("Probe Set ID", "Gene")]

# Find the number of matching names in the same position
identical(df_annotated_probes_R2$ProbeName,merged_df$`Probe Set ID`) #make sure every ID is the same in both df
sum(df_annotated_probes_R2$GeneName==merged_df$Gene)/length(merged_df$Gene)*100

```

There are 42872 probe sets that are annotated in both ways, using the R package and the annotation file. From this probe sets, 92,79% have exactly the same Gene Symbol. 3090 probe sets have a different annotated gene name, but that doesn't mean that the gene is different. As we can see next, there are some probe sets that refer to the same gene, but the Gene Symbol is the previous used or a synonymous. It can may happen that, for a probe set, more than one possible gene is identified. In this analysis we keep with the first annotated gene, but maybe the R package is selecting the second of the TF file.

```{r}
#How many probe ID are differently annotated
sum(df_annotated_probes_R2$GeneName!=merged_df$Gene)

# Example of probe sets with different Gene
grep('1558480_at',merged_df$`Probe Set ID`)
df_annotated_probes_R2[3536,]
merged_df[3536,]

df_annotated_probes_R2[6707,]
merged_df[6707,]
  
```

For example, the probe set 1558480_at in the R hgu133plus2.db package is annotated as TMCC1-DT. However, in the Thermo fisher annotation file, is as TMCC1-AS1. As it indicates the HUGO Gene Nomenclature Committee (HGNC), the approved symbol is TMCC1-DT, but the previous one was TMCC1-AS1. The same occurs with the probe set 1569973_at. The approved symbol is SEPTIN7P2 and the previous one was SEPT7P2. So, both annotation methods make reference to the same gene, although the name is different and this affects the percentage of same gene symbols between the annotated probe sets in R and in the Thermo fisher. In conclusion, the percentage of gene symbols shared by the R hgu133plus2.db package and the Thermo fisher file, is indeed higher than 92,72%. 


Let's check whether the genomic position of the 229 non-annotated probes using the thermo fisher file that were annotated using R, corresponds to the gene that is annotated. We will use the UCSC Genome browser on Human, version GRCh37/hg19. 

```{r,warning=FALSE}
# Select the probes annotated in R but not in the Thermo fisher file.
TF_no_annotated_yesR<-df_TF_or[df_TF_or$`Gene Symbol`=='---',]
probes_id<-TF_no_annotated_yesR$`Probe Set ID`
rownames(HG_U133_Plus_2_na36_annot)<-HG_U133_Plus_2_na36_annot$`Probe Set ID`
head(HG_U133_Plus_2_na36_annot[probes_id,c(1,13:16)])

rownames(df_annotated_probes_R_pack)<-df_annotated_probes_R_pack$ProbeName
head(df_annotated_probes_R_pack[probes_id,])

```


So, the genomic location of the probe sets is in the annotation file. We will select the the coordinates for each probe, search them in the USCS genome browser, and compare if the gene is the same that annotated using the R package. 

For the first probe, 1552976_at, the genomic coordinates correspond to the gene DNAJB13, which is the same that was annotated. 

![](C:/Users/MARINA/Documents/MASTER/TFM/Data_analysis/1552976_at.jpg)



For the probe 1554194_at, we can see that the genomic coordinates corresponds to C8orf58 gene, and the gene annotated in the R package is a LOC. In this case, the gene do not match. 
![](C:/Users/MARINA/Documents/MASTER/TFM/Data_analysis/1554194_at.jpg)


After analyzing and comparing the annotations by the two different approaches, we decide to keep with the downstream analysisi with those probes sets annotated by the Thermo Fisher file. Since the annotation file is provided by the microarray manufacturer, it is considered an official, curated and reliable source of information, ensuring accuracy. On the other hand, the R package for probe annotations is typically maintained by researchers or bioinformatics, which are more versatile. 

In conclusion, we will keep the analysis with the probe sets that were annotated using the Thermo fisher annotation file. In total, we retrieve 45056 probe sets. 

```{r}
annotated_probes_TF<-HG_U133_Plus_2_na36_annot[HG_U133_Plus_2_na36_annot$`Gene Symbol`!='---',]
annotated_probes_TF2<-annotated_probes_TF[,c("Probe Set ID", "Gene Symbol")]

# Select the probe sets that have more than one gene symbol annotation, and continue with the first annotation.
pos_multiplegenes<-grep('///',annotated_probes_TF2$`Gene Symbol`)
df_TF_multiplegenes<-annotated_probes_TF2[pos_multiplegenes,]

split_values2 <- NULL
for (i in 1:nrow(df_TF_multiplegenes)){
  split_values2[i] <- strsplit(df_TF_multiplegenes$`Gene Symbol`, " /// ")[[i]][1]
  }
df_TF_multiplegenes$Unique_Gene_symbol<-unlist(split_values2)

# Create a data frame with the probe name and with only one Gene symbol annotation.
merged_df <- merge(annotated_probes_TF2, df_TF_multiplegenes, by = "Probe Set ID", all.x = TRUE)
merged_df<-merged_df[,-3]
# Update the Gene column with the values from the second data frame
merged_df$Gene <- ifelse(is.na(merged_df$Unique_Gene_symbol), merged_df$`Gene Symbol.x`, merged_df$Unique_Gene_symbol)
merged_df <- merged_df[, c("Probe Set ID", "Gene")]


pos_probes_expressionmatrix<-which(data %in% merged_df$`Probe Set ID`)
final_expression_matrix <- as.matrix(expression_brca[pos_probes_expressionmatrix, ])

# We need to change the rownames for the probe names of the Thermo fisher file
new_probesets_<-paste(merged_df$`Probe Set ID`,merged_df$Gene,sep = '_')
rownames(final_expression_matrix)<-new_probesets_

dim(final_expression_matrix)

```


## Remove duplicated probe set genes

It is frequent that different probe sets correspond to the same gene. Once the probe sets are annotated, we have to remove duplicated genes. Otherwise, the analysis can lead to biased and inaccurate results. 

The implemented function, will select the expression values of the duplicated genes, and will compute the mean value for each individual. It will return a list containing each repeated gene, and the mean expression values for each sample. Finally, we will create a matrix, that contains the expression values of both unique and previous duplicated genes. 

```{r}
# --- REMOVE DUPLICATED ----

symbols<-merged_df$Gene

# ----- FUNCTION ----

find_repeated_genes <- function(vector, matrix) {
  # Find repeated gene names
  repeated_names <- names(table(vector))[table(vector) > 1]
  
  # Initialize a list to store the mean values
  repeated_means <- list()
  
  # Iterate over each repeated gene
  for (gene_name in repeated_names) {
    # Find the positions of the repeated gene in the vector
    positions <- which(vector == gene_name)
    
    # Find the rows in the matrix that correspond to the positions
    rows <- matrix[positions, , drop = FALSE]
    
    # Calculate the mean by column for the rows
    means <- colMeans(rows)
    
    # Store the means in the list
    repeated_means[[gene_name]] <- means
  }
  
  # Return the list of mean values for each repeated gene
  return(repeated_means)
}

# Call the function to find the rows of the repeated genes in the matrix
result <- find_repeated_genes(symbols, final_expression_matrix)

# Extract the gene names
gene_names <- names(result)

# Create a matrix with row names for genes and columns for samples
mat <- matrix(unlist(result), nrow = length(gene_names), byrow = TRUE)

# Add row names to the matrix
rownames(mat) <- gene_names
colnames(mat) <- colnames(exprs(brca.rma))

dim(mat)


# --- Get unique genes ---

# Create a table of gene counts
gene_counts <- table(symbols)

# Extract the genes that occur only once
unique_genes <- names(gene_counts[gene_counts == 1])

#Extract the position of the unique genes.
unique_gene_pos<-match(unique_genes,symbols)

# Search in the matrix, the position of the unique genes 
matrix_unique_genes<-final_expression_matrix[unique_gene_pos,]
rownames(matrix_unique_genes)<-gsub("^.*_", "",rownames(matrix_unique_genes))

# Join the two matrices
final_matrix<-rbind(matrix_unique_genes,mat)
brca.noduplicated<-final_matrix[order(rownames(final_matrix)),]
dim(brca.noduplicated)

# We need to transform the matrix object brca.noduplicated to an ExpressionSet
library(Biobase)
brca.noduplicated<-ExpressionSet(assayData = brca.noduplicated)
pData(brca.noduplicated)<-pdata
```

After removing the duplicated genes, we end up with a matrix that contains the expression levels of 21923 genes. 


# Deconvolution based method

Before applying deconvolution, we have to make sure that the input data is: 

1. Normalized

2. not log-transformed.

The data was normalized in the previous steps, and the transformation of not log data will be performed next, when running the deconvolution. 
## Cibersort

In order to use Cibersort, we require to have in local the cibersort source code, that contains two files. These files are downloaded from the cibersort website. 

```{r}
#Set the path to the directory were the deconvolution cibersort files are. 
deconvDir <- file.path("C:/Users/MARINA/Documents/MASTER/TFM/Deconvolution_files")
cibersort_binary = file.path(deconvDir, "CIBERSORT.R")
cibersort_mat = file.path(deconvDir, "CIBERSORT_LM22.txt")

CIBERSORT_LM22 <- read.delim("~/MASTER/TFM/Deconvolution_files/CIBERSORT_LM22.txt", row.names=1)


# Separate radiated from non-radiated
NOR<-pdata[pdata$Treatment=='NOR',]
RAD<-pdata[pdata$Treatment=='RAD',]
# 
radiated_samples<-rownames(RAD)
non_radiated_samples<-rownames(NOR)


```

Cibersort, allows to perform between cell-type comparisons. That means, for example, for sample SG-17.cel, there are more T cell CD4+ memory activated cells than T cell CD8+.

If we want to perform between sample comparisons, we need to use other methods, such as Timer, epic, or cibersort abs. mode (provides a score that can be compared between both samples and cell types). 


## Cibersort abs. mode

We will use cibersort abs. mode, which is a method that provides an score that allows for the comparison of both between cell types, and samples comparisons. 

```{r,warning=FALSE}
library(immunedeconv)
res_cib_abs=deconvolute_cibersort(2^exprs(brca.noduplicated),arrays = TRUE, absolute = TRUE)
#load(file='res_cis_abs.RData')

res_cib_abs <- data.frame(cell_type=rownames(res_cib_abs),res_cib_abs)
res_cib_abs <- res_cib_abs[,-1]
res_cib_abs <- res_cib_abs %>% mutate(across(where(is.numeric), round, 3))
colnames(res_cib_abs)<-gsub('_2','',colnames(res_cib_abs))
datatable(res_cib_abs) 


# ---  Load the data ---
library(readxl)
Patient_info <- as.data.frame(read_excel("../Patient info.xlsx"))

# --- Prepare it ---
# Change the row names for their array code identification
rownames(Patient_info)<-Patient_info$`ARRAY CODE`
rownames(Patient_info)<-gsub('LL','L',rownames(Patient_info))
rownames(Patient_info)<-gsub('SG-127.CEL','X127.CEL',rownames(Patient_info))
rownames(Patient_info)<-gsub('SG-13.CEL','SG-103.CEL',rownames(Patient_info))
rownames(Patient_info)<-gsub('SG-14.CEL','SG-104.CEL',rownames(Patient_info))
rownames(Patient_info)<-gsub('-','.',rownames(Patient_info))

ind<-match(colnames(res_cib_abs),row.names(Patient_info))
Patient_info<-Patient_info[ind,]
identical(colnames(res_cib_abs),row.names(Patient_info))

```

Once we have obtained the table of the cell fractions for all the cell types and samples, we can start by assessing its variability in the different conditions we want to study. 

In order to know which statistical test is the most appropriate one, we will start by performing a shapiro.test, to assess the normality of the data. 

For each cell type, 2 hypothesis are made: 

- H0: Data follow a normal distribution.

- H1: Data do not follow a normal distribution.

If p-value is greater than 0.05, data follows a normal distribution, whereas if the p-value is less than 0.05 data do not follow a normal distribution, and this will condition the type of test to be used. 

```{r}
# remove cell types that do not have at least 5 unique values
distinct_values_count <- apply(res_cib_abs, 1, function(x) length(unique(x)))

# Subset the data frame to include rows with at least 5 distinct values
df_filtered <- res_cib_abs[distinct_values_count >= 5, ]


test<-apply(df_filtered,1,function(x) shapiro.test(x)$p.value)
test
notdistributed<-df_filtered

# Normal distribution 
hist(as.numeric(df_filtered[16,]))

# Not normal distribution
hist(as.numeric(df_filtered[8,]))

```

Only the data from dendritic cell type and the total score follows a normal distribution. As most of the cell types do not follow a normal distribution, we will treat all the data as not normal distributed, and we will apply a Wilcoxon for testing paired data for testing the equality of 2 means. 

### Not normally distributed data cell types

We will start by a general overview, so we will assess the mean differences between 2 general groups: radiated vs non-radiated samples.  

In this code, the mean for each cell type is calculated by each group.
```{r}
# Separate radiated from non-radiated
table(pdata$Treatment)

# vector of conditions
condition_rad_norad=pdata$Treatment

mean_values<-NULL
for (i in 1: nrow(notdistributed)){
    mean<-tapply((unlist(notdistributed[i,-107])),condition_rad_norad, mean)
    rownam<-rownames(notdistributed[i,])
    mean_values<-c(mean_values,c(rownam,mean))
    }


# Function to format the mean_values into groups of 3
format_mean_values <- function(values) {
  result <- list()
  num_values <- length(values)
  i <- 1
  while (i <= num_values) {
    result <- c(result, list(values[i:(i + 2)]))
    i <- i + 3
  }
  return(result)
}

mean_values <- format_mean_values(mean_values)

# Convert mean_values to a data frame
mean_values_df <- do.call(rbind, mean_values)
mean_values_df <- as.data.frame(mean_values_df)

# Rename the columns
colnames(mean_values_df) <- c("Condition", "NOR", "RAD")

mean_values_df$NOR<-round(as.numeric(mean_values_df$NOR),4)
mean_values_df$RAD<-round(as.numeric(mean_values_df$RAD),4)

mean_values_df
```

As you can see there is no big differences between the mean cell fraction of no radiated and radiated samples. However, we will perform a wilcoxon test to assess if there are statistical differences. 

Apply statistical tests:

```{r}
# --- radiated vs no-radiated --------------
wilcox.test(unlist(notdistributed['T cells CD8',1:106])~condition_rad_norad)

pvals<-NULL
for (i in 1:nrow(notdistributed)){
  pval<-wilcox.test(unlist(notdistributed[i,])~condition_rad_norad)$p.val
  pvals<-c(pvals,pval)
}

notdistributed$pvals<-pvals

df<-notdistributed[,106:107] #106:107
df[-1]

```

There are 3 p-values that are less than 0.05, which means that there are statistically evidences to reject the null hypothesis (H0) and thus, the alternative hypothesis (H1) is considered to be proved. So, our results provide support for the hypothesis that there are significant differences between the mean expression of the radiated and non radiated levels of T cells regulatory (Tregs), Macrophages MO, and the total absolute score. 

In the other hand, the rest of the cell types present a p-value higher than 0.05, which indicates that there are no statistical significant differences between the mean expression levels of radiated and no-radiated samples. 

#### Total CD4 cell type

The main interest of this study is the T CD4 cell type. As cibesort provides detailed information regarding them, and separates the lymphocytes depending on their subgroups (naive or memory activated),we will aggregate them by summing up their expression value for each sample. 

```{r}
# Select T cells CD4 naive
T_CD4_naive_ciber<-notdistributed['T cells CD4 naive',-107]#107
T_CD4_naive_ciber<-as.data.frame(t(T_CD4_naive_ciber))


# Select T cells CD4 memory activated
T_CD4_memory_act_ciber<-notdistributed['T cells CD4 memory activated',-107]
T_CD4_memory_act_ciber<-as.data.frame(t(T_CD4_memory_act_ciber))

# Select total T CD4 cells 
TCD4_cibersort<-notdistributed[c('T cells CD4 naive','T cells CD4 memory activated'),-107]

Total_T_CD4_ciber<-colSums(TCD4_cibersort)
Total_T_CD4_ciber<-as.data.frame(Total_T_CD4_ciber)
Total_T_CD4_ciber

```

### Sankey Plot

In order to visualize the proportion of cell types across samples, we will perform Sankey plots. To properly visualize the plots and to make them informative, we will separate the samples depending on their phenotype (BRCA1 healthy, BRCA1 affected, BRCA2 healthy, BRCA2 affected, NOMUT healthy and NOMUT affected) for no-radiated samples. We will also select those cell types that its mean values are higher than 0.05.

```{r}
library(ggalluvial)

noradiated<-rownames(pdata[pdata$Treatment=='NOR',])
noradiated2<-as.vector(gsub('-','.',noradiated))
noradiated2<-as.vector(gsub('127.CEL','X127.CEL',noradiated2))

res_norad<-notdistributed[,noradiated2]
sub_resnorad<-res_norad[-20,]
sub_resnorad<-sub_resnorad[which(apply(sub_resnorad,1,mean)>0.05),]
rownames(sub_resnorad)[3]<-'TCD4 memory activated'
rownames(sub_resnorad)[4]<-'T follicular helper'
rownames(sub_resnorad)[5]<-'T regulatory'


#----------------BRCA1 affected-------------------------------------
BRCA1.AF<-rownames(pdata[pdata$Phenotype=='BRCA1.AF',])
BRCA1.AF<-as.vector(gsub('-','.',BRCA1.AF))
pos<-which(colnames(sub_resnorad) %in% BRCA1.AF)

res_noradBRCA1.AF<-sub_resnorad[,pos]

# Put all data in a single vector
vectors<-NULL
for (i in 1:ncol(res_noradBRCA1.AF)){
  vector<-res_noradBRCA1.AF[,i]
  vectors<-c(vectors,vector)
}

data_plot <- data.frame(
  sample = rep(colnames(res_noradBRCA1.AF), each = 9),
  cell_type = rep(rownames(res_noradBRCA1.AF), times = 10),
  value=vectors)


ggplot(data = data_plot,
       aes(axis1 = sample, axis2 = cell_type, y = value)) +
  geom_alluvium(aes(fill = cell_type)) +
  geom_stratum() +
  geom_text(stat = "stratum",
            aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("sample", "Cell type"),
                   expand = c(0.15, 0.05)) +
  theme_void() + ggtitle('   Cell type distributions in BRCA1 cancer-affected samples')

#----------------BRCA1 healthy-------------------------------------
BRCA1.SA<-rownames(pdata[pdata$Phenotype=='BRCA1.SA',])
BRCA1.SA<-as.vector(gsub('-','.',BRCA1.SA))
BRCA1.SA<-as.vector(gsub('127.CEL','X127.CEL',BRCA1.SA))
pos<-which(colnames(sub_resnorad) %in% BRCA1.SA)

res_noradBRCA1.SA<-sub_resnorad[,pos]

# Put all data in a single vector
vectors<-NULL
for (i in 1:ncol(res_noradBRCA1.SA)){
  vector<-res_noradBRCA1.SA[,i]
  vectors<-c(vectors,vector)
}

data_plot.SA <- data.frame(
  sample = rep(colnames(res_noradBRCA1.SA), each = 9),
  cell_type = rep(rownames(res_noradBRCA1.SA), times = 8),
  value=vectors)


ggplot(data = data_plot.SA,
       aes(axis1 = sample, axis2 = cell_type, y = value)) +
  geom_alluvium(aes(fill = cell_type)) +
  geom_stratum() +
  geom_text(stat = "stratum",
            aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("sample", "Cell type"),
                   expand = c(0.15, 0.05)) +
  theme_void() +ggtitle('   Cell type distributions in BRCA1 healthy samples')

#----------------BRCA2 affected-------------------------------------
BRCA2.AF<-rownames(pdata[pdata$Phenotype=='BRCA2.AF',])
BRCA2.AF<-as.vector(gsub('-','.',BRCA2.AF))
pos<-which(colnames(sub_resnorad) %in% BRCA2.AF)

res_noradBRCA2.AF<-sub_resnorad[,pos]

# Put all data in a single vector
vectors<-NULL
for (i in 1:ncol(res_noradBRCA2.AF)){
  vector<-res_noradBRCA2.AF[,i]
  vectors<-c(vectors,vector)
}

data_plot2.AF <- data.frame(
  sample = rep(colnames(res_noradBRCA2.AF), each = 9),
  cell_type = rep(rownames(res_noradBRCA2.AF), times = 11),
  value=vectors)


ggplot(data = data_plot2.AF,
       aes(axis1 = sample, axis2 = cell_type, y = value)) +
  geom_alluvium(aes(fill = cell_type)) +
  geom_stratum() +
  geom_text(stat = "stratum",
            aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("sample", "Cell type"),
                   expand = c(0.15, 0.05)) +
  theme_void() +ggtitle('   Cell type distributions in BRCA2 cancer-affected samples')


#----------------BRCA2 healthy-------------------------------------
BRCA2.SA<-rownames(pdata[pdata$Phenotype=='BRCA2.SA',])
BRCA2.SA<-as.vector(gsub('-','.',BRCA2.SA))
pos<-which(colnames(sub_resnorad) %in% BRCA2.SA)

res_noradBRCA2.SA<-sub_resnorad[,pos]

# Put all data in a single vector
vectors<-NULL
for (i in 1:ncol(res_noradBRCA2.SA)){
  vector<-res_noradBRCA2.SA[,i]
  vectors<-c(vectors,vector)
}

data_plot2.SA <- data.frame(
  sample = rep(colnames(res_noradBRCA2.SA), each = 9),
  cell_type = rep(rownames(res_noradBRCA2.SA), times = 9),
  value=vectors)


ggplot(data = data_plot2.SA,
       aes(axis1 = sample, axis2 = cell_type, y = value)) +
  geom_alluvium(aes(fill = cell_type)) +
  geom_stratum() +
  geom_text(stat = "stratum",
            aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("sample", "Cell type"),
                   expand = c(0.15, 0.05)) +
  theme_void()+ggtitle('   Cell type distributions in BRCA2 healthy samples')

#----------------NOMUT healthy-------------------------------------
NOMUT.SA<-rownames(pdata[pdata$Phenotype=='NOMUT.SA',])
NOMUT.SA<-as.vector(gsub('-','.',NOMUT.SA))
pos<-which(colnames(sub_resnorad) %in% NOMUT.SA)

res_noradNOMUT.SA<-sub_resnorad[,pos]

# Put all data in a single vector
vectors<-NULL
for (i in 1:ncol(res_noradNOMUT.SA)){
  vector<-res_noradNOMUT.SA[,i]
  vectors<-c(vectors,vector)
}

data_plotNOMUT.SA <- data.frame(
  sample = rep(colnames(res_noradNOMUT.SA), each = 9),
  cell_type = rep(rownames(res_noradNOMUT.SA), times = 10),
  value=vectors)


ggplot(data = data_plotNOMUT.SA,
       aes(axis1 = sample, axis2 = cell_type, y = value)) +
  geom_alluvium(aes(fill = cell_type)) +
  geom_stratum() +
  geom_text(stat = "stratum",
            aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("sample", "Cell type"),
                   expand = c(0.15, 0.05)) +
  theme_void()+ggtitle('   Cell type distributions in NO MUTATED healthy samples')


#----------------NOMUT affected-------------------------------------
NOMUT.AF<-rownames(pdata[pdata$Phenotype=='NOMUT.AF',])
NOMUT.AF<-as.vector(gsub('-','.',NOMUT.AF))
pos<-which(colnames(sub_resnorad) %in% NOMUT.AF)

res_noradNOMUT.AF<-sub_resnorad[,pos]

# Put all data in a single vector
vectors<-NULL
for (i in 1:ncol(res_noradNOMUT.AF)){
  vector<-res_noradNOMUT.AF[,i]
  vectors<-c(vectors,vector)
}

data_plotNOMUT.AF <- data.frame(
  sample = rep(colnames(res_noradNOMUT.AF), each = 9),
  cell_type = rep(rownames(res_noradNOMUT.AF), times = 5),
  value=vectors)


ggplot(data = data_plotNOMUT.AF,
       aes(axis1 = sample, axis2 = cell_type, y = value)) +
  geom_alluvium(aes(fill = cell_type)) +
  geom_stratum() +
  geom_text(stat = "stratum",
            aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("sample", "Cell type"),
                   expand = c(0.15, 0.05)) +
  theme_void()+ggtitle('   Cell type distributions in NO MUTATED cancer-affected samples')

```



## EPIC

We will also perform deconvolution using the EPIC method. 

```{r,warning=FALSE}
res_epic2 = deconvolute(2^exprs(brca.noduplicated),array=TRUE , "epic") 
res_epic <- res_epic2 %>% mutate(across(where(is.numeric), round, 3))
datatable(res_epic) 

res_epic<-as.data.frame(res_epic)
rownames(res_epic)<-res_epic$cell_type
res_epic<-res_epic[,-1]

test<-apply(res_epic,1,function(x) shapiro.test(x)$p.value)
test
pos<-which(test<0.05)
notdistributed<-res_epic[pos,]


```

In this case, all the cell types are not normal distributed. We will perform the same procedure that was done on Cibersort abs. mode: assessing the mean differences between 2 general groups: radiated vs non-radiated samples.


```{r}
# --- radiated vs no-radiated --------------

# Separate radiated from non-radiated
table(pdata$Treatment)

# vector of conditions
condition_rad_norad=pdata$Treatment

mean_values<-NULL
for (i in 1: nrow(notdistributed)){
    mean<-tapply((unlist(notdistributed[i,-107])),condition_rad_norad, mean)
    rownam<-rownames(notdistributed[i,])
    mean_values<-c(mean_values,c(rownam,mean))
    }

# Function to format the mean_values into groups of 3
format_mean_values <- function(values) {
  result <- list()
  num_values <- length(values)
  i <- 1
  while (i <= num_values) {
    result <- c(result, list(values[i:(i + 2)]))
    i <- i + 3
  }
  return(result)
}

mean_values <- format_mean_values(mean_values)

# Convert mean_values to a data frame
mean_values_df <- do.call(rbind, mean_values)
mean_values_df <- as.data.frame(mean_values_df)

# Rename the columns
colnames(mean_values_df) <- c("Condition", "NOR", "RAD")

mean_values_df$NOR<-round(as.numeric(mean_values_df$NOR),4)
mean_values_df$RAD<-round(as.numeric(mean_values_df$RAD),4)

mean_values_df


pvals<-NULL
for (i in 1:nrow(res_epic)){
  pval<-wilcox.test(unlist(res_epic[i,-107])~condition_rad_norad)$p.val
  pvals<-c(pvals,pval)
}
res_epic$pvals<-pvals

res_epic[,c(1,107)]

```

Just the p-value of the Macrophage cell type is less than 0.05, which suggest that there are significant differences in the expression between radiated and non radiated samples. In the rest of the cell types, the p-value is higher than 0.05, which indicates that there are not significant differences between the mean of the cell types of radiated and no radiated samples.

### T cell CD4 EPIC

Let's prepare the T cell CD4 variable to perform a correlation analysis. 
```{r}
# Get T CD4+ cells expression levels. 
T_CD4_epic<-res_epic['T cell CD4+',-107]
T_CD4_epic<-t(T_CD4_epic)
T_CD4_epic<-as.data.frame(T_CD4_epic)
T_CD4_epic
```


## MIXTURE

Finally, we will also perform deconvolution by using the MIXTURE method, based in cibersort. 

```{r,warning=FALSE,message=FALSE}
library(MIXTURE)
res_mixt<-MIXTURE(2^exprs(brca.noduplicated),signatureMatrix = CIBERSORT_LM22)
res_m<-as.data.frame(t(res_mixt$Subjects$MIXabs))

# remove cell types that do not have at least 5 unique values
distinct_values_count <- apply(res_m, 1, function(x) length(unique(x)))

# Subset the data frame to include rows with at least 5 distinct values
df_filtered <- res_m[distinct_values_count >= 5, ]


test<-apply(df_filtered,1,function(x) shapiro.test(x)$p.value)
test
pos<-which(test<0.05)

```

As most of the cell types do not follow a normal distribution, we will treat all the data as not normal distributed, and we will apply a Wilcoxon for testing paired data for testing the equality of 2 means. 

### Not normally distributed data cell types

```{r}
# Separate radiated from non-radiated
table(pdata$Treatment)

# vector of conditions
condition_rad_norad=pdata$Treatment

mean_values<-NULL
for (i in 1: nrow(df_filtered)){
    mean<-tapply((unlist(df_filtered[i,])),condition_rad_norad, mean)
    rownam<-rownames(df_filtered[i,])
    mean_values<-c(mean_values,c(rownam,mean))
    }

# Function to format the mean_values into groups of 3
format_mean_values <- function(values) {
  result <- list()
  num_values <- length(values)
  i <- 1
  while (i <= num_values) {
    result <- c(result, list(values[i:(i + 2)]))
    i <- i + 3
  }
  return(result)
}

mean_values <- format_mean_values(mean_values)

# Convert mean_values to a data frame
mean_values_df <- do.call(rbind, mean_values)
mean_values_df <- as.data.frame(mean_values_df)

# Rename the columns
colnames(mean_values_df) <- c("Condition", "NOR", "RAD")

mean_values_df$NOR<-round(as.numeric(mean_values_df$NOR),4)
mean_values_df$RAD<-round(as.numeric(mean_values_df$RAD),4)

mean_values_df
```

Apply statistical tests:

```{r}
# --- radiated vs no-radiated --------------

pvals<-NULL
for (i in 1:nrow(df_filtered)){
  pval<-wilcox.test(unlist(df_filtered[i,])~condition_rad_norad)$p.val
  pvals<-c(pvals,pval)
}

df_filtered$pvals<-pvals

df<-df_filtered[,106:107]
df[-1]

```

Only the Macrophages.MO cell type has a p-value less than 0.05. The other cell types present a p-value higher than 0.05, which suggests that there are no statistically significant differences between the mean expression values of radiated and non radiated samples. 


#### Total T CD4 cells

```{r}
# Select T cells CD4 naive
T_CD4_naive_mixt<-df_filtered['T.cells.CD4.naive',-107]
T_CD4_naive_mixt<-as.data.frame(t(T_CD4_naive_mixt))


# Select T cells CD4 memory activated
T_CD4_memory_act_mixt<-df_filtered['T.cells.CD4.memory.activated',-107]
T_CD4_memory_act_mixt<-as.data.frame(t(T_CD4_memory_act_mixt))


# Select T CD4 cells 
TCD4_mixture<-df_filtered[c('T.cells.CD4.naive','T.cells.CD4.memory.activated'),-107]

#apply(TCD4_mixture,2,sum)
Total_T_CD4_mixture<-colSums(TCD4_mixture)
Total_T_CD4_mixture<-as.data.frame(Total_T_CD4_mixture)
Total_T_CD4_mixture
```


In conclusion from the deconvolution analysis, the proportion of T CD4 cell type in all the 3 methods is very high, and there is no significant differences between the mean expression values of this cell types between radiated and non radiated samples. 


## CORRELATIONS

In this section, correlation analysis between the 3 deconvolution methods used will be performed. The goal is to try to identify which method will be used to obtain the TCD4 cell type covariate to include it in the variable selection with LASSO step. 

### Correlation EPIC-MIXTURE

```{r,warning=FALSE,message=FALSE}
library(ggplot2)
library(ggpubr)
T_cellcd4_mixt_epic<-cbind(Total_T_CD4_mixture,T_CD4_epic)
colnames(T_cellcd4_mixt_epic)<-c('TCD4_MIXTURE','TCD4_EPIC')

cor.test(T_cellcd4_mixt_epic$TCD4_MIXTURE,T_cellcd4_mixt_epic$TCD4_EPIC,method = 'spearman')

ggplot(data=T_cellcd4_mixt_epic,aes(x = TCD4_MIXTURE, y = TCD4_EPIC)) + geom_point(color='black')+stat_smooth(method = 'lm') + 
  ggtitle('Correlation TCD4 EPIC and TCD4 MIXTURE') +xlab('TCD4 MIXTURE') +ylab('TCD4 EPIC')
```

### Correlation CIBERSORT-MIXTURE

```{r,warning=FALSE}
T_cellcd4_ciber_mixt<-cbind(Total_T_CD4_ciber,Total_T_CD4_mixture)
colnames(T_cellcd4_ciber_mixt)<-c('TCD4_CIBERSORT_abs','TCD4_MIXTURE')

cor.test(T_cellcd4_ciber_mixt$TCD4_CIBERSORT_abs,T_cellcd4_ciber_mixt$TCD4_MIXTURE,method = 'spearman')

ggplot(data=T_cellcd4_ciber_mixt,aes(x = TCD4_CIBERSORT_abs, y = TCD4_MIXTURE)) + geom_point(color='black')+stat_smooth(method = 'lm') + 
  ggtitle('Correlation TCD4 CIBERSORT abs mode and TCD4 MIXTURE') +xlab('TCD4 CIBERSORT abs mode') +ylab('TCD4 MIXTURE')
```


As both Cibersort and MIXTURE present detailed TCD4 cell types, we will assess the correlation between TCD4 naive and memory activated cell types. 

#### CD4 NAIVE

```{r,warning=FALSE}
T_cd4_naive_both<-cbind(T_CD4_naive_ciber,T_CD4_naive_mixt)
colnames(T_cd4_naive_both)<-c('naive_CIBERSORT_abs','naive_MIXT')

cor.test(T_cd4_naive_both$naive_CIBERSORT_abs,T_cd4_naive_both$naive_MIXT,method = 'spearman')

ggplot(data=T_cd4_naive_both,aes(x = naive_CIBERSORT_abs, y = naive_MIXT)) + geom_point(color='black')+stat_smooth(method = 'lm') + 
  ggtitle('Correlation TCD4 naive CIBERSORT abs mode and TCD4 naive MIXTURE') +xlab('TCD4 naive CIBERSORT abs mode') +ylab('TCD4 naive MIXTURE')
```

#### CD4 MEMORY ACTIVATED

```{r,warning=FALSE}
T_cd4_MEMORY_both<-cbind(T_CD4_memory_act_ciber,T_CD4_memory_act_mixt)
colnames(T_cd4_MEMORY_both)<-c('CIBERSORT_abs','MIXT')

cor.test(T_cd4_MEMORY_both$CIBERSORT_abs,T_cd4_MEMORY_both$MIXT,method = 'spearman')

ggplot(data=T_cd4_MEMORY_both,aes(x = CIBERSORT_abs, y = MIXT)) + geom_point(color='black')+stat_smooth(method = 'lm') + 
  ggtitle('Correlation TCD4 memory activated CIBERSORT and  MIXTURE') +xlab('TCD4 memory activated CIBERSORT abs mode') +ylab('TCD4 memory activated MIXTURE')
```

### Correlation CIBERSORT-EPIC

```{r,warning=FALSE}
T_cellcd4_ciber_epic<-cbind(Total_T_CD4_ciber,T_CD4_epic)
colnames(T_cellcd4_ciber_epic)<-c('TCD4_CIBERSORT_abs','TCD4_EPIC')

cor.test(T_cellcd4_ciber_epic$TCD4_CIBERSORT_abs,T_cellcd4_ciber_epic$TCD4_EPIC,method = 'spearman')

ggplot(data=T_cellcd4_ciber_epic,aes(x = TCD4_CIBERSORT_abs, y = TCD4_EPIC)) + geom_point(color='black')+stat_smooth(method = 'lm') + 
  ggtitle('Correlation TCD4 CIBERSORT abs mode and TCD4 EPIC') +xlab('TCD4 CIBERSORT') +ylab('TCD4 EPIC')
```


In conclusion, we can see that Cibersort abs.mode and MIXTURE are the 2 methods that are highly correlated, which is what we expected as MIXTURE is based in cibersort. In the other hand, we can see that the correlation is not strong when using EPIC, as it tends to overestimate the fraction of cell types. For this reason, EPIC will be discarded. Then, we have no evidence that MIXTURE provides an score that allow to perform both between cell and between sample comparisons, so for this reason, we will use CIBERSORT abs. mode as the method to obtain the TCD4 cell type expression and to use it as a covariate in LASSO and in Differential expression analysis steps. 

# Subset no-radiated samples

From now on, we will focus on the analysis of no-radiated samples.

```{r}
noradiated<-rownames(pdata[pdata$Treatment=='NOR',])
length(noradiated)

brca.noduplicated.norad<-brca.noduplicated[,noradiated]
dim(brca.noduplicated.norad)
```

# Filtering

There are different approaches to filter data, avoiding unexpressed genes or genes that do not vary among different conditions. In this case, we will filter by standard deviation.

```{r,warning==FALSE}
head(exprs(brca.noduplicated.norad[grep('BRCA|MYC',rownames(exprs(brca.noduplicated.norad))),]))[,1:5]
```

Before filtering we have the presence of both BRCA1 and BRCA2 genes. BRCA1 expression levels are a little bit higher than BRCA2. Then, there are 4 genes related to the MYC family, being the MYC with the highest expression gene. 

Different filtering criteria was applied (standard deviation 0.75, 0.5 and no filtering). 0.75 resulted to be too stringent, so we kept with the standard deviation 0.5 filtering criteria.

```{r}
sd <- apply(exprs(brca.noduplicated.norad),1,sd)
summary(sd)
threshold<-quantile(sd,0.5)

top.pos<-which(sd>threshold)
brca.rma.norad_filt<-brca.noduplicated.norad[top.pos,]

dim(brca.rma.norad_filt)
pData(brca.rma.norad_filt)<-pdata[noradiated,]
```

After filtering, we keep with 10961 probe sets.

```{r}
brca<-exprs(brca.rma.norad_filt)
exprs(brca.rma.norad_filt[grep('BRCA|MYC',rownames(exprs(brca.rma.norad_filt))),])[,1:5]

rownames(brca)[1]<-'TCONS_00029157'
brca<-brca[order(rownames(brca)),]

brca<-ExpressionSet(assayData = brca)

#rownames(pdata)<-gsub('-','.',rownames(pdata))
#rownames(pdata)<-gsub('127.CEL','X127.CEL',rownames(pdata))

pData(brca)<-pdata[noradiated,]
colnames(brca)

head(exprs(brca))[,1:5]

```

BRCA1 and BCRA2 both pass the filtering step and 3 genes from the MYC family, which means that the standard deviation of the expression levels of these genes is over the 2nd quantile of standard deviation.

# Variable selection binomial

This approach takes into account the differences in predictor effects across the comparisons. It allows to identify the specific predictor variables that are associated with each comparison. In this case, it's reasonable to expect that certain predictor variables may not have an effect in all the comparisons. For example, if a predictor variable represents chemotherapy treatment, it may only be relevant in comparisons involving individuals who have undergone chemotherapy. 

Therefore, using a binomial approach for variable selection will allow to capture these specific associations and identify predictor variables that are relevant to each comparison separately, so we will get the variables that are better adjusted with the phenotype, in this case.  This can provide more accurate and meaningful results for your analysis.

We want to study the next comparisons: 

- BRCA1.AF vs NOMUT.AF

- BRCA1.SA VS NOMUT.SA

- BRCA2.AF VS NOMUT.AF

- BRCA2.SA VS NOMUT.SA


```{r}
# ---  Load the data ---
library(readxl)
Patient_info <- as.data.frame(read_excel("../Patient info.xlsx"))

# --- Prepare it ---
# Change the row names for their array code identification
rownames(Patient_info)<-Patient_info$`ARRAY CODE`
rownames(Patient_info)<-gsub('LL','L',rownames(Patient_info))
rownames(Patient_info)<-gsub('SG-127.CEL','X127.CEL',rownames(Patient_info))
rownames(Patient_info)<-gsub('SG-13.CEL','SG-103.CEL',rownames(Patient_info))
rownames(Patient_info)<-gsub('SG-14.CEL','SG-104.CEL',rownames(Patient_info))
rownames(Patient_info)<-gsub('-','.',rownames(Patient_info))


#Rename smoking variable of patients
Patient_info$`SMOKING HISTORY`[Patient_info$`SMOKING HISTORY`=='EX']<-'SI'
Patient_info$`SMOKING HISTORY`[Patient_info$`SMOKING HISTORY`=='Yes']<-'SI'

Patient_info$`YEARS AFTER RADIO`[is.na(Patient_info$`YEARS AFTER RADIO`)]<-0
Patient_info$`YEARS AFTER QUIMIO`[is.na(Patient_info$`YEARS AFTER QUIMIO`)]<-0

# Get only no-radiated samples
noradiated<-gsub('-','.',noradiated)
noradiated<-gsub('127.CEL','X127.CEL',noradiated)
Patient_info<-Patient_info[noradiated,]

# Remove NA patients from smoking history
Patients_smoking<-Patient_info[!is.na(Patient_info$`SMOKING HISTORY`),]
smoking_NA<-Patient_info[is.na(Patient_info$`SMOKING HISTORY`),]
dim(smoking_NA) # 7 patients have NA for smoking history

colnames(brca)<-gsub('-','.',colnames(brca))
colnames(brca)<-gsub('127.CEL','X127.CEL',colnames(brca))
smoking_samples<-intersect(colnames(brca),rownames(Patients_smoking))

#Select only the patients with smoking information from the filtered and normalized object
brca_smoking<-brca[,smoking_samples]

#Transform to factor
Patients_smoking$`SMOKING HISTORY`<-as.factor(Patients_smoking$`SMOKING HISTORY`)
Patients_smoking$RADIO<-as.factor(Patients_smoking$RADIO)
Patients_smoking$QUIMIO<-as.factor(Patients_smoking$QUIMIO)
#str(Patients_smoking)

#Add phenotype
Patients_smoking$Phenotype<-pData(brca_smoking)$Phenotype
Patients_smoking$Phenotype<-as.factor(Patients_smoking$Phenotype)
```

Check the column names and the row names are in the same order:
```{r}
identical(rownames(Patients_smoking),colnames(brca_smoking))
Patients_smoking$Phenotype<-pData(brca_smoking)$Phenotype

table(Patients_smoking$Phenotype)
```

## Data summary

Summary of the important variables:

```{r,warning=FALSE}
library(tableone)

factor(Patient_info$CARRIER)
#Rename smoking variable of patients
Patient_info$CARRIER[Patient_info$CARRIER=='NUMUT']<-'NUMUT'
Patient_info$CARRIER[Patient_info$CARRIER=='CAN-ESPOR']<-'NUMUT'

Patients_smoking$CARRIER[Patients_smoking$CARRIER=='NUMUT']<-'NUMUT'
Patients_smoking$CARRIER[Patients_smoking$CARRIER=='CAN-ESPOR']<-'NUMUT'


tableOne<-CreateTableOne(data=Patient_info[,c(6,7,8,15,16,17,18,19,20)])
tableOne_smoking<-CreateTableOne(data=Patients_smoking[,c(6,7,8,15,16,17,18,19,20,21)])
summary(tableOne)
summary(tableOne_smoking)
#print(tableOne, showAllLevels = TRUE, formatOptions = list(big.mark = ","))
```

## BRCA1 

### - BRCA1.SA vs NOMUT.SA

Only 3 variables to consider: age, smoking and cibersort.

```{r,warning=FALSE}
# --- Select the patients that have this condition ---
Patients_brca1.sa<-Patients_smoking[Patients_smoking$Phenotype=='BRCA1.SA'| Patients_smoking$Phenotype=='NOMUT.SA',]
brca_smk_brca1.sa<-brca[,rownames(Patients_brca1.sa)]
#str(Patients_brca1.sa)

# --- Variable selection ---
ybrca1.sa<-as.factor(Patients_brca1.sa$Phenotype)
xbrca1.sa<-Patients_brca1.sa[,c('AGE, EXTRACTION TIME','SMOKING HISTORY')]

Total_T_CD4_cibersort<-data.frame(Total_T_CD4_ciber)
Total_T_CD4_cibersort_brca1<-as.data.frame(Total_T_CD4_ciber[intersect(rownames(Total_T_CD4_ciber),rownames(Patients_brca1.sa)),])
rownames(Total_T_CD4_cibersort_brca1)<-intersect(rownames(Total_T_CD4_ciber),rownames(Patients_brca1.sa))
colnames(Total_T_CD4_cibersort_brca1)<-'Total_T_CD4_ciber'

x <- model.matrix(ybrca1.sa~xbrca1.sa$`AGE, EXTRACTION TIME`+ xbrca1.sa$`SMOKING HISTORY`+Total_T_CD4_cibersort_brca1$Total_T_CD4_ciber-1)
x<-x[,-2]

# Fit the model
lasso_model <- cv.glmnet(x, ybrca1.sa, family = "binomial", standardize=TRUE)

# Select the optimal lambda value based on cross-validation
optimal_lambda <- lasso_model$lambda.min

coef(lasso_model,s=optimal_lambda)

```

The model has shrinked to 0 all the coefficients for the 3 variables we were considering, so in this case, LASSO suggests that no variables have an impact to the phenotype. 


### - BRCA1.AF vs NOMUT.AF

Now, as we are selecting cancer affected patients, we have to consider other variables such as chemotherapy, radiotherapy, and the years that have passed after the patient underwent these treatments. 

```{r,warning=FALSE}
Patients_smoking$QUIMIO<-as.factor(Patients_smoking$QUIMIO)
Patients_smoking$RADIO<-as.factor(Patients_smoking$RADIO)
Patients_smoking$`SMOKING HISTORY`<-as.factor(Patients_smoking$`SMOKING HISTORY`)

# --- Select the patients that have this condition ---
Patients_brca1.af<-Patients_smoking[Patients_smoking$Phenotype=='BRCA1.AF'| Patients_smoking$Phenotype=='NOMUT.AF',]
brca_smk_brca1.af<-brca[,rownames(Patients_brca1.af)]

# --- Variable selection ---
ybrca1.af<-as.factor(Patients_brca1.af$Phenotype)
xbrca1.af<-Patients_brca1.af[,c('AGE, EXTRACTION TIME','QUIMIO','RADIO','YEARS AFTER QUIMIO','YEARS AFTER RADIO','SMOKING HISTORY')]

rownames(Patients_brca1.af)<-gsub('-','.',rownames(Patients_brca1.af))

Total_T_CD4_cibersort_BRCA.AF<-as.data.frame(Total_T_CD4_ciber[intersect(rownames(Total_T_CD4_ciber),rownames(Patients_brca1.af)),])
rownames(Total_T_CD4_cibersort_BRCA.AF)<-intersect(rownames(Total_T_CD4_ciber),rownames(Patients_brca1.af))
colnames(Total_T_CD4_cibersort_BRCA.AF)<-'Total_T_CD4_ciber'


x <- model.matrix(ybrca1.af~xbrca1.af$`AGE, EXTRACTION TIME`+xbrca1.af$QUIMIO+xbrca1.af$RADIO+xbrca1.af$`YEARS AFTER QUIMIO`+xbrca1.af$`YEARS AFTER RADIO`+xbrca1.af$`SMOKING HISTORY`+Total_T_CD4_cibersort_BRCA.AF$Total_T_CD4_ciber-1)
x<-x[,-2]

# Fit the model
lasso_model <- cv.glmnet(x, ybrca1.af, family = "binomial", standardize=TRUE)

# Select the optimal lambda value based on cross-validation
optimal_lambda <- lasso_model$lambda.min

coef(lasso_model,s=optimal_lambda)
```

In this case, LASSO indicates that age and smoking have an impact the the phenotype, so this variables will be added to the Limma model. 

As we will compare within BRCA1 carriers, the two models, BRCA1.healthy vs NOMUT.healthy and BRCA1.affected and NOMUT.affected need to have the same variables. For this reason, when performing the differential expression analysis, we will add smoking and age as covariates for both of the models (healthy and affected).

## BRCA2

We will repeat the same process for BRCA2.

### - BRCA2.SA VS NOMUT.SA

```{r,warning=FALSE}
# --- Select the patients that have this condition ---
Patients_brca2.sa<-Patients_smoking[Patients_smoking$Phenotype=='BRCA2.SA'| Patients_smoking$Phenotype=='NOMUT.SA',]
brca_smk_brca2.sa<-brca[,rownames(Patients_brca2.sa)]


# --- Variable selection ---
ybrca2.sa<-as.factor(Patients_brca2.sa$Phenotype)
xbrca2.sa<-Patients_brca2.sa[,c('AGE, EXTRACTION TIME','SMOKING HISTORY')]


Total_T_CD4_ciber_brca2.sa<-as.data.frame(Total_T_CD4_ciber[intersect(rownames(Total_T_CD4_ciber),rownames(Patients_brca2.sa)),])
rownames(Total_T_CD4_ciber_brca2.sa)<-intersect(rownames(Total_T_CD4_ciber),rownames(Patients_brca2.sa))
colnames(Total_T_CD4_ciber_brca2.sa)<-'Total_T_CD4_ciber'


x <- model.matrix(ybrca2.sa~xbrca2.sa$`AGE, EXTRACTION TIME`+ xbrca2.sa$`SMOKING HISTORY`+Total_T_CD4_ciber_brca2.sa$Total_T_CD4_ciber-1)
x<-x[,-2]

# Fit the model
lasso_model <- cv.glmnet(x, ybrca2.sa, family = "binomial", standardize=TRUE)

# Select the optimal lambda value based on cross-validation
optimal_lambda <- lasso_model$lambda.min

coef(lasso_model,s=optimal_lambda)


```

In this case, all the variables that were possible to consider are important for the model, as LASSO do not shrink its coefficient to 0.

### - BRCA2.AF VS NOMUT.AF


```{r,warning=FALSE}
# --- Select the patients that have this condition ---
Patients_brca2.af<-Patients_smoking[Patients_smoking$Phenotype=='BRCA2.AF'| Patients_smoking$Phenotype=='NOMUT.AF',]
brca_smk_brca2.af<-brca[,rownames(Patients_brca2.af)]

# --- Variable selection ---
ybrca2.af<-as.factor(Patients_brca2.af$Phenotype)
xbrca2.af<-Patients_brca2.af[,c('AGE, EXTRACTION TIME','QUIMIO','RADIO','YEARS AFTER QUIMIO','YEARS AFTER RADIO','SMOKING HISTORY')]


rownames(Patients_brca2.af)<-gsub('-','.',rownames(Patients_brca2.af))

Total_T_CD4_ciber_brca2.af<-as.data.frame(Total_T_CD4_ciber[intersect(rownames(Total_T_CD4_ciber),rownames(Patients_brca2.af)),])
rownames(Total_T_CD4_ciber_brca2.af)<-intersect(rownames(Total_T_CD4_ciber),rownames(Patients_brca2.af))
colnames(Total_T_CD4_ciber_brca2.af)<-'Total_T_CD4_ciber'

x <- model.matrix(ybrca2.af~xbrca2.af$`AGE, EXTRACTION TIME`+xbrca2.af$QUIMIO+xbrca2.af$RADIO+xbrca2.af$`YEARS AFTER QUIMIO`+xbrca2.af$`YEARS AFTER RADIO`+xbrca2.af$`SMOKING HISTORY` +Total_T_CD4_ciber_brca2.af$Total_T_CD4_ciber -1)
x<-x[,-2]

# Fit the model
lasso_model <- cv.glmnet(x, ybrca2.af, family = "binomial", standardize=TRUE)

# Select the optimal lambda value based on cross-validation
optimal_lambda <- lasso_model$lambda.min

coef(lasso_model,s=optimal_lambda)


```

Finally, for this comparison, LASSO selects age, quimio, radio, and smoking. 

Again, we should have the same model (same covariates) within the BRCA2 models to compare between them. That is, in the BRCA2 healthy comparison, we will add all the 3 variables LASSO returned, but in BRCA2 affected comparisons, we will also add CIBERSORT, although LASSO do not select it. For the affected samples comparison, we will also add chemotherapy and radiotherapy, although it is exclusively for affected patients, as healthy do not undergo cancer treatments. Despite this fact, we will consider that the models are identical, and we will compare between them.


# Differential expression analysis

In this section, we will perform the differential expression analysis with LIMMA, and adding the covariates LASSO returned for each comparison. Those significant differential expressed genes will be those that whose adjusted p-value is less than 0.05, and its absolute logFC value is over 1. 

## BRCA1.SA vs NOMUT.SA
```{r}
# --- Select the patients that have this condition ---
Patients_brca1_sa<-Patients_smoking[Patients_smoking$Phenotype=='BRCA1.SA'| Patients_smoking$Phenotype=='NOMUT.SA',]
brca_smk_sa1<-brca[,rownames(Patients_brca1_sa)]

#Check the order of the colnames of expression matrix and rownames of phenodata is the same
identical(colnames(brca_smk_sa1),rownames(Patients_brca1_sa))

age<-Patients_brca1_sa$`AGE, EXTRACTION TIME`
smok<-Patients_brca1_sa$`SMOKING HISTORY`
cond<-as.factor(pData(brca_smk_sa1)$Phenotype) #Phenotype

#arrayweights
arrayw <- arrayWeights(brca_smk_sa1)
# barplot(arrayw, xlab="Array", ylab="Weight", col="white", las=2)
# abline(h=1, lwd=1, lty=2)


# Design a matrix
design <- model.matrix(~0+cond+age+smok)
rownames(design) <- sampleNames(brca_smk_sa1)
colnames(design) <- gsub("cond", "", colnames(design))

# Fit the model 
fit <- lmFit(brca_smk_sa1, design,weights = arrayw) 


# --- Contrasts ---
contrast.matrix <- makeContrasts(cond1=BRCA1.SA-NOMUT.SA,
                                 levels = design)

# --- Fit contrasts and Bayesian adjustment ---
fit2 <- contrasts.fit(fit, contrast.matrix)
fite <- eBayes(fit2)


# --- Extract results ---
# BRCA1.SA vs NOMUT.SA
top.table.brca1.sa <- topTable(fite, coef = 'cond1', number = Inf, adjust = "fdr")
head(top.table.brca1.sa)

# --- Distribution of p-values ---
hist(top.table.brca1.sa$P.Value, breaks = 100, main = "results P-value")

```

##BRCA1.AF vs NOMUT.AF
```{r}
# --- Select the patients that have this condition ---
Patients_brca1_af<-Patients_smoking[Patients_smoking$Phenotype=='BRCA1.AF'| Patients_smoking$Phenotype=='NOMUT.AF',]
brca_smk_af1<-brca[,rownames(Patients_brca1_af)]
str(Patients_brca1_af)

#Check the order of the colnames of expression matrix and rownames of phenodata is the same
identical(colnames(brca_smk_af1),rownames(Patients_brca1_af))

cond<-as.factor(pData(brca_smk_af1)$Phenotype) #Phenotype
age_brca1_af<- Patients_brca1_af$`AGE, EXTRACTION TIME` # Age
smoking_brca1_af<-Patients_brca1_af$`SMOKING HISTORY`
radio1af<-Patients_brca1_af$RADIO
quimio1af<-Patients_brca1_af$QUIMIO
yearsquimio1af<-Patients_brca1_af$`YEARS AFTER QUIMIO`
yearsradio1af<-Patients_brca1_af$`YEARS AFTER RADIO`

#arrayweights
arraywbrca1.af <- arrayWeights(brca_smk_af1)

# Design a matrix
design <- model.matrix(~0+cond+smoking_brca1_af+age_brca1_af)
rownames(design) <- sampleNames(brca_smk_af1)
colnames(design) <- gsub("cond", "", colnames(design))

# Fit the model 
fit <- lmFit(brca_smk_af1, design, weights = arraywbrca1.af) 

# --- Contrasts ---
contrast.matrix2 <- makeContrasts(cond1=BRCA1.AF-NOMUT.AF,
                                 levels = design)

# --- Fit contrasts and Bayesian adjustment ---
fit2 <- contrasts.fit(fit, contrast.matrix2)
fite <- eBayes(fit2)

# --- Extract results ---
# BRCA1.AF vs NOMUT.AF
top.table.brca1.af <- topTable(fite, coef = 'cond1', number = Inf, adjust = "fdr")
head(top.table.brca1.af)

# --- Distribution of p-values ---
hist(top.table.brca1.af$P.Value, breaks = 100, main = "results P-value")

```

## BRCA2.SA vs NOMUT.SA

```{r}
# --- Select the patients that have this condition ---
Patients_brca2_sa<-Patients_smoking[Patients_smoking$Phenotype=='BRCA2.SA'| Patients_smoking$Phenotype=='NOMUT.SA',]
brca_smk_sa2<-brca[,rownames(Patients_brca2_sa)]
str(Patients_brca2_sa)

#Check the order of the colnames of expression matrix and rownames of phenodata is the same
identical(colnames(brca_smk_sa2),rownames(Patients_brca2_sa))

cond<-as.factor(pData(brca_smk_sa2)$Phenotype) #Phenotype
age_brca_sa2<- Patients_brca2_sa$`AGE, EXTRACTION TIME` # Age
smoking_brca_sa2<-Patients_brca2_sa$`SMOKING HISTORY`

# Prepare the cibersort variable
rownames(Patients_brca2_sa)<-gsub('-','.',rownames(Patients_brca2_sa))
commonsamples<-intersect(rownames(Total_T_CD4_ciber),rownames(Patients_brca2_sa))
cibersort<-Total_T_CD4_ciber[commonsamples,]


# Design a matrix
design <- model.matrix(~0+cond+age_brca_sa2+smoking_brca_sa2+cibersort)
rownames(design) <- sampleNames(brca_smk_sa2)
colnames(design) <- gsub("cond", "", colnames(design))


#arrayweights
arraywbrca2.sa <- arrayWeights(brca_smk_sa2)

# Fit the model 
fit <- lmFit(brca_smk_sa2, design, weights = arraywbrca2.sa) 

# --- Contrasts ---
contrast.matrix <- makeContrasts(cond1=BRCA2.SA-NOMUT.SA,
                                 levels = design)

# --- Fit contrasts and Bayesian adjustment ---
fit2 <- contrasts.fit(fit, contrast.matrix)
fite <- eBayes(fit2)

# --- Extract results ---
# BRCA2.SA vs NOMUT.SA
top.table.brca2.sa <- topTable(fite, coef = 'cond1', number = Inf, adjust = "fdr")
head(top.table.brca2.sa)

# --- Distribution of p-values ---
hist(top.table.brca2.sa$P.Value, breaks = 100, main = "results P-value")

```

In this comparison, there is one gene that is significantly differentially expressed between BRCA2 healthy and NOMUT healthy, LOC100653061, as the adjusted p-value is less than 0.05, and the absolute value of LogFC is over 1. 

## BRCA2.AF vs NOMUT.AF

```{r}
# --- Select the patients that have this condition ---
Patients_brca2.af<-Patients_smoking[Patients_smoking$Phenotype=='BRCA2.AF'| Patients_smoking$Phenotype=='NOMUT.AF',]
brca_smk_brca2.af<-brca[,rownames(Patients_brca2.af)]

# Create a vector of conditions 
cond<-as.factor(pData(brca_smk_brca2.af)$Phenotype) #Phenotype
age_brca2.af<- Patients_brca2.af$`AGE, EXTRACTION TIME` # Age
smoking_brca2.af<-Patients_brca2.af$`SMOKING HISTORY`
radio_brca2.af<-Patients_brca2.af$RADIO
quimio_brca2.af<-Patients_brca2.af$QUIMIO

table(radio_brca2.af)
yearsquimio<-Patients_brca2.af$`YEARS AFTER QUIMIO`
yearsradio<- Patients_brca2.af$`YEARS AFTER RADIO`

rownames(Patients_brca2.af)<-gsub('-','.',rownames(Patients_brca2.af))
commonsamples<-intersect(rownames(Total_T_CD4_ciber),rownames(Patients_brca2.af))
cibersort<-Total_T_CD4_ciber[commonsamples,]

#arrayweights
arraywbrca2.af <- arrayWeights(brca_smk_brca2.af)

# Design a matrix
design <- model.matrix(~0+cond+smoking_brca2.af+quimio_brca2.af+age_brca2.af+cibersort)
rownames(design) <- sampleNames(brca_smk_brca2.af)
colnames(design) <- gsub("cond", "", colnames(design))

# Fit the model 
fit <- lmFit(brca_smk_brca2.af, design, weights = arraywbrca2.af) 

# --- Contrasts ---
contrast.matrix <- makeContrasts(cond1=BRCA2.AF-NOMUT.AF,levels = design)

# --- Fit contrasts and Bayesian adjustment ---
fit2 <- contrasts.fit(fit, contrast.matrix)
fite <- eBayes(fit2)

# --- Extract results ---
# BRCA2.AF vs NOMUT.AF
top.table.brca2.AF <- topTable(fite, coef = 'cond1', number = Inf, adjust = "fdr")
head(top.table.brca2.AF)

# --- Distribution of p-values ---
hist(top.table.brca2.AF$P.Value, breaks = 100, main = "results P-value")
```

## Rank gene list

For the next step, the Gene Set Enrichment Analysis, we need a list with the whole genes of genes ordered. In this case, we will use the combination of the sign of the logFC and the log10 of the P.value to create a metric to rank all the genes. 

```{r}
# --- BRCA1.SA vs NOMUT.SA ----
sign=sign(top.table.brca1.sa$logFC)
logP=-log10(top.table.brca1.sa$P.Value)
metric=logP*sign
geneList = metric
names(geneList) = rownames(top.table.brca1.sa)
geneList_brca1.sa = sort(geneList, decreasing = TRUE)

gene_names_list_brca1.sa <- names(geneList_brca1.sa)

# --- BRCA1.AF vs NOMUT.AF ----
signbrca1af=sign(top.table.brca1.af$logFC)
logPbrca1af=-log10(top.table.brca1.af$P.Value)
metricbrca1.af=logPbrca1af*signbrca1af
geneList_brca1_af = metricbrca1.af
names(geneList_brca1_af) = rownames(top.table.brca1.af)
geneList_brca1_af = sort(geneList_brca1_af, decreasing = TRUE)

gene_names_list_brca1.af <- names(geneList_brca1_af)

# --- BRCA2.SA vs NOMUT.SA ---
signbrca2=sign(top.table.brca2.sa$logFC)
logP_brca2=-log10(top.table.brca2.sa$P.Value)
metricbrca2=logP_brca2*signbrca2
geneList_brca2_sa = metricbrca2
names(geneList_brca2_sa) = rownames(top.table.brca2.sa)
geneList_brca2_sa = sort(geneList_brca2_sa, decreasing = TRUE)


gene_names_list_brca2.sa <- names(geneList_brca2_sa)

# --- BRCA2.AF vs NOMUT.AF ---
signbrca2af=sign(top.table.brca2.AF$logFC)
logP_brca2af=-log10(top.table.brca2.AF$P.Value)
metricbrca2af=logP_brca2af*signbrca2af
geneList_brca2_af = metricbrca2af
names(geneList_brca2_af) = rownames(top.table.brca2.AF)
geneList_brca2_af = sort(geneList_brca2_af, decreasing = TRUE)

gene_names_list_brca2.af <-  names(geneList_brca2_af)
```


# Functional analysis

The steps to perform gene set enrichment analysis comparing different conditions are described next. 

- First, data has to be normalized and preprocessed, which is done and explained in the previous steps.

- Define curated gene sets or pathways. There are gene set databases like MSigDB (Molecular Signatures Database) or Reactome, that provide pre-defined gene sets representing various biological processes and pathways. 

- Perform differential gene expression analysis comparing the different conditions. The aim of this step is to obtain a complete list of genes (ALL genes) ranked by an statistical parameter. In this case, to rank the genes of the sample data results, we will combine the sign of the logFC and the p-value.

- Conduct GSEA analysis. clusterProfiler R package enables to perform GSEA analysis. 

We will use MSigDB to get the gene set collections. Within this database, we can access to Hallmark or to curated gene sets, which include canonical pathways gene sets derived from the Reactome database. The GSEA is perform using the Hallmark gene set collection and the Reactome. Results are finally compared. 

## GSEA - mSigDB -Hallmark

We will use data from the hallmark gene set collection. Hallmark gene sets are coherently expressed signatures derived by aggregating many MSigDB gene sets to represent well-defined biological states or processes. In this collection, there are 50 gene sets.


```{r,warning=FALSE}
library(enrichplot)
library(msigdbr)

h_gene_sets = msigdbr(species = "Homo sapiens", category = "H")
H.entrez <- h_gene_sets %>% dplyr::select(gs_name, entrez_gene)
H.symbol <- h_gene_sets %>% dplyr::select(gs_name, gene_symbol)

```



### BRCA1.SA vs NOMUT.SA
```{r,warning=FALSE,message=FALSE}
library(ggplot2)
library(clusterProfiler)
set.seed(123)
resGsea <- GSEA(geneList_brca1.sa, TERM2GENE = H.symbol)
head(resGsea)

#plots
resGseaR<-resGsea@result[resGsea@result$p.adjust<0.05,]

# Barplot
barplot=ggplot(resGseaR, aes(x=ID, y=NES,fill=p.adjust)) + 
  geom_bar(stat = "identity") +
  scale_fill_continuous(low='red', high='blue')+
  coord_flip() +
  theme_bw()

barplot


```

The gene sets with a positive NES value, indicate that there is an enrichment at the top of the ranked gene list. On the other hand, for those gene sets whose NES value is negative, that means they are enriched at the bottom of the ranked gene list. 

Most of the positive gene sets are related with cell proliferation pathways.

List of negative gene sets: 
```{r}
# --- Negative NES Pathways ---
negative_pathways_brca1_sa<-resGseaR[resGseaR$NES<0,]$ID
negative_pathways_brca1_sa
```

List of positive gene sets:
```{r}
# --- Positive NES Pathways ---
positive_pathways_brca1_sa<-resGseaR[resGseaR$NES>0,]$ID
positive_pathways_brca1_sa
```


### BRCA1.AF vs NOMUT.AF

```{r,warning=FALSE}
set.seed(123)
resGsea.brca1.af <- GSEA(geneList_brca1_af, TERM2GENE = H.symbol)
head(resGsea.brca1.af)

#plots
resGseaR.brca1.af<-resGsea.brca1.af@result[resGsea.brca1.af@result$p.adjust<0.05,]


p=ggplot(resGseaR.brca1.af, aes(x=ID, y=NES,fill=p.adjust)) + 
  geom_bar(stat = "identity") +
  scale_fill_continuous(low='red', high='blue')+
  coord_flip() +
  theme_bw()

p

```


```{r}
# --- Negative NES Pathways ---
negative_pathways_brca1_af<-resGsea.brca1.af[resGsea.brca1.af$NES<0,]$ID
negative_pathways_brca1_af
```

```{r}
# --- Positive NES Pathways ---
positive_pathways_brca1_af<-resGsea.brca1.af[resGsea.brca1.af$NES>0,]$ID
positive_pathways_brca1_af

```

### BRCA2.SA vs NOMUT.SA
```{r,warning=FALSE}
set.seed(123)
resGsea_brca2.sa <- GSEA(geneList_brca2_sa, TERM2GENE = H.symbol)
head(resGsea_brca2.sa)

resGseaR_brca2.sa<-resGsea_brca2.sa@result[resGsea_brca2.sa@result$p.adjust<0.05,]


p=ggplot(resGseaR_brca2.sa, aes(x=ID, y=NES,fill=p.adjust)) + 
  geom_bar(stat = "identity") +
  scale_fill_continuous(low='red', high='blue')+
  coord_flip() +
  theme_bw()

p

```


```{r}
# --- Negative NES Pathways ---
negative_pathways_brca2_sa<-resGseaR_brca2.sa[resGseaR_brca2.sa$NES<0,]$ID
negative_pathways_brca2_sa
```

```{r}
# --- Positive NES Pathways ---
positive_pathways_brca2_sa<-resGseaR_brca2.sa[resGseaR_brca2.sa$NES>0,]$ID
positive_pathways_brca2_sa
```



### BRCA2.AF vs NOMUT.AF

```{r,warning=FALSE}
set.seed(123)
resGsea.brca2.af <- GSEA(geneList_brca2_af, TERM2GENE = H.symbol)
head(resGsea.brca2.af)

#plots
resGseaR.brca2.af<-resGsea.brca2.af@result[resGsea.brca2.af@result$p.adjust<0.05,]

p=ggplot(resGseaR.brca2.af, aes(x=ID, y=NES,fill=p.adjust)) + 
  geom_bar(stat = "identity") +
  scale_fill_continuous(low='red', high='blue')+
  coord_flip() +
  theme_bw()

p

```

```{r}
# --- Negative NES Pathways ---
negative_pathways_brca2_af<-resGseaR.brca2.af[resGseaR.brca2.af$NES<0,]$ID
negative_pathways_brca2_af
```

```{r}
# --- Positive NES Pathways ---
positive_pathways_brca2_af<-resGseaR.brca2.af[resGseaR.brca2.af$NES>0,]$ID
```

### Comparisons
#### BRCA1.SA vs BRCA1.AF

It is interesting to study the comparison between BRCA1 of healthy and affected samples. 

Let's retrieve a list of positive pathways shared between BRCA1 healthy and BRCA1 affected:

```{r,message=FALSE}
library(VennDiagram)
intersect(positive_pathways_brca1_sa,positive_pathways_brca1_af)
venn.diagram(
  x = list(positive_pathways_brca1_sa, positive_pathways_brca1_af),
  category.names = c("BRCA1.HEALTHY", "BRCA1.AFFECTED"),
  filename = 'hall_positive_venn_diagramm_brca1_vs_brca1_50filt.png',
  output = TRUE,
  main = 'Positive BRCA1 Healthy vs Positive BRCA1 Affected',
  col = "transparent",
  fill = c('forestgreen', 'coral'),
  print.mode=c("raw","percent"),cat.pos = c(-27, 160),cat.dist= c(0.02,-0.05))
```
![](C:/Users/MARINA/Documents/MASTER/TFM/Pictures/hallmark_brca1healthy_brca1_aff_positive.jpg)

Negative pathways shaded between BRCA1 healthy and BRCA1 affected:
```{r}
intersect(negative_pathways_brca1_sa,negative_pathways_brca1_af)
venn.diagram(
  x = list(negative_pathways_brca1_sa, negative_pathways_brca1_af),
  category.names = c("BRCA1.HEALTHY", "BRCA1.AFFECTED"),
  filename = 'hall_negative_venn_diagramm_brca1_vs_brca1_50filt.png',
  output = TRUE,
  main = 'Negative BRCA1 Healthy vs Negative BRCA1 Affected',
  col = "transparent",
  fill = c('forestgreen', 'coral'),
  print.mode=c("raw","percent"),cat.pos = c(-27, 160),cat.dist= c(0.02,-0.05))
```
![](C:/Users/MARINA/Documents/MASTER/TFM/Pictures/hallmark_brca1healthy_brca1_aff_negative.jpg)


Positive BRCA1 healthy pathways that are negative in BRCA1 affected
```{r}
intersect(positive_pathways_brca1_sa,negative_pathways_brca1_af)
venn.diagram(
  x = list(positive_pathways_brca1_sa, negative_pathways_brca1_af),
  category.names = c("BRCA1.HEALTHY", "BRCA1.AFECTED"),
  filename = 'hall_pos_neg_venn_diagramm_brca1sa_vs_brca1af_50filt.png',
  output = TRUE,
  main = 'Venn diagram BRCA1 Healthy vs BRCA1 Afected',
  col = "transparent",
  fill = c('forestgreen', 'coral'),
  print.mode=c("raw","percent"))
```
There are no pathways shared between positive BRCA1 healthy and negative BRCA1 affected.



Negative BRCA1 healthy pathways that are positive in BRCA1 affected
```{r}
intersect(negative_pathways_brca1_sa,positive_pathways_brca2_af)
venn.diagram(
  x = list(negative_pathways_brca1_sa, positive_pathways_brca2_af),
  category.names = c("BRCA1.HEALTHY", "BRCA1.AFFECTED"),
  filename = 'msigdb_neg_pos_venn_diagramm_brca1sa_vs_brca1af_50filt.png',
  output = TRUE,
  main = 'Venn diagram BRCA1 Healthy vs BRCA1 Affected',
  col = "transparent",
  fill = c('forestgreen', 'coral'),
  print.mode=c("raw","percent"))
```
There are no pathways shared between negative BRCA1 healthy and positive BRCA1 affected. 


#### BRCA2.SA vs BRCA2.AF

And finally, for the hallmark gene set collection, we will study the comparisons between BRCA2 healthy and BRCA2 affected samples. 

Positive pathways shared between BRCA2 healthy and BRCA2 affected:
```{r}
intersect(positive_pathways_brca2_sa,positive_pathways_brca2_af)
venn.diagram(
  x = list(positive_pathways_brca2_sa, positive_pathways_brca2_af),
  category.names = c("BRCA2.HEALTHY", "BRCA2.AFFECTED"),
  filename = 'hallmark_positive_venn_diagramm_brca2_vs_brca2_50filt.png',
  output = TRUE,
  main = 'Venn diagram BRCA2 Healthy vs BRCA2 Affected',
  col = "transparent",
  fill = c('forestgreen', 'coral'),
  print.mode=c("raw","percent"))
```
 No positive pathways shared between BRCA2 healthy and affected.
 
 
Negative pathways shaded between brca2 healthy and brca2 afected:
```{r}
intersect(negative_pathways_brca2_sa,negative_pathways_brca2_af)
venn.diagram(
  x = list(negative_pathways_brca2_sa, negative_pathways_brca2_af),
  category.names = c("BRCA2.HEALTHY", "BRCA2.AFFECTED"),
  filename = 'hallmark_negative_venn_diagramm_brca2_vs_brca2_50filt.png',
  output = TRUE,
  main = 'Venn diagram negative BRCA2 Healthy vs BRCA2 Affected',
  col = "transparent",
  fill = c('forestgreen', 'coral'),
  print.mode=c("raw","percent"),cat.pos = c(-27, 160),cat.dist= c(0.02,-0.05))
```
![](C:/Users/MARINA/Documents/MASTER/TFM/Pictures/hallmark_negative_brca2.jpg)

Positive BRCA2 healthy pathways that are negative in BRCA2 affected:
```{r}
intersect(positive_pathways_brca2_sa,negative_pathways_brca2_af)

venn.diagram(
  x = list(positive_pathways_brca2_sa, negative_pathways_brca2_af),
  category.names = c("BRCA2.HEALTHY", "BRCA2.AFFECTED"),
  filename = 'hallmark_pos_neg_venn_diagramm_brca2_vs_brca2_50filt.png',
  output = TRUE,
  main = 'Positive BRCA2 Healthy vs Negative BRCA2 Affected',
  col = "transparent",
  fill = c('forestgreen', 'coral'),
  print.mode=c("raw","percent"),cat.pos = c(-27, 160),cat.dist= c(0.02,-0.05))
```
No pathways shared between positive BRCA2 healthy and negative in BRCA2 affected.


Negative BRCA2 healthy pathways that are positive in BRCA2 affected:
```{r}
intersect(negative_pathways_brca2_sa,positive_pathways_brca2_af)
venn.diagram(
  x = list(negative_pathways_brca2_sa, positive_pathways_brca2_af),
  category.names = c("BRCA2.HEALTHY", "BRCA2.AFFECTED"),
  filename = 'hallmark_neg_pos_venn_diagramm_brca2sa_vs_brca2af_50filt.png',
  output = TRUE,
  main = 'Venn diagram BRCA2 Healthy vs BRCA2 Affected',
  col = "transparent",
  fill = c('forestgreen', 'coral'),
  print.mode=c("raw","percent"))
```
No negative pathways of BRCA2 healthy shared with the positive pathways of BRA2 affected.

## GSEA - mSigDB - Reactome

This helper function shows the available collections.
```{r}
msigdbr_collections()
```


We will select the Reactome subset of canonical patwhays within the C2 collection. There are 1654 gene sets, so we expect to see a higher number of gene sets in our analysis compared with the hallamrk. 

```{r}
library(msigdbr)

reactome_gene_sets = msigdbr(species = "Homo sapiens", category = "C2", subcategory = 'CP:REACTOME')
R.entrez <- reactome_gene_sets %>% dplyr::select(gs_name, entrez_gene)
R.symbol <- reactome_gene_sets %>% dplyr::select(gs_name, gene_symbol)
```

### BRCA1.SA VS NOMUT.SA

```{r,warning=FALSE}

set.seed(123)
react.brca1.sa<- GSEA(geneList_brca1.sa, TERM2GENE = R.symbol)
react.brca1.sa<-react.brca1.sa@result[react.brca1.sa@result$p.adjust<0.05,]
head(react.brca1.sa)

#positive NES
positive_NES_reactome_brca1.sa<-react.brca1.sa[react.brca1.sa$NES>0,]$ID
length(positive_NES_reactome_brca1.sa)

#negative NES
negative_NES_reactome_brca1.sa<-react.brca1.sa[react.brca1.sa$NES<0,]$ID
length(negative_NES_reactome_brca1.sa)

```

### BRCA1.AF vs NOMUT.AF

```{r,warning=FALSE}
set.seed(123)
react.brca1.af <- GSEA(geneList_brca1_af, TERM2GENE = R.symbol)
react.brca1.af<-react.brca1.af@result[react.brca1.af@result$p.adjust<0.05,]
head(react.brca1.af)

#positive
positive_NES_reactome_brca1.af<-react.brca1.af[react.brca1.af$NES>0,]$ID
length(positive_NES_reactome_brca1.af)

#negative NES
negative_NES_reactome_brca1.af<-react.brca1.af[react.brca1.af$NES<0,]$ID
length(negative_NES_reactome_brca1.af)


```


### BRCA2.SA VS NOMUT.SA
```{r,warning=FALSE}
set.seed(123)
react.brca2.sa <- GSEA(geneList_brca2_sa, TERM2GENE = R.symbol)
react.brca2.sa<-react.brca2.sa@result[react.brca2.sa@result$p.adjust<0.05,]
head(react.brca2.sa)

#positive NES
positive_NES_reactome_brca2.sa<-react.brca2.sa[react.brca2.sa$NES>0,]$ID
length(positive_NES_reactome_brca2.sa)

#negative NES
negative_NES_reactome_brca2.sa<-react.brca2.sa[react.brca2.sa$NES<0,]$ID
length(negative_NES_reactome_brca2.sa)

```


### BRCA2.AF vs NOMUT.AF

```{r}
set.seed(123)
react.brca2.af <- GSEA(geneList_brca2_af, TERM2GENE = R.symbol)
react.brca2.af<-react.brca2.af@result[react.brca2.af@result$p.adjust<0.05,]
head(react.brca2.af)


#positive
positive_NES_reactome_brca2.af<-react.brca2.af[react.brca2.af$NES>0,]$ID
length(positive_NES_reactome_brca2.af)

#negative NES
negative_NES_reactome_brca2.af<-react.brca2.af[react.brca2.af$NES<0,]$ID
length(negative_NES_reactome_brca2.af)

```
### Comparisons
#### BRCA1.SA vs BRCA1.AF

Positive pathways shared between BRCA1 healthy and BRCA1 affected:

```{r}

intersect(positive_NES_reactome_brca1.sa,positive_NES_reactome_brca1.af)
venn.diagram(
  x = list(positive_NES_reactome_brca1.sa, positive_NES_reactome_brca1.af),
  category.names = c("BRCA1.HEALTHY", "BRCA1.AFFECTED"),
  filename = 'reactome_positive_venn_diagramm_brca1_vs_brca1_50filt.png',
  output = TRUE,
  main = 'Positive BRCA1 Healthy vs Positive BRCA1 Affected',
  col = "transparent",
  fill = c('forestgreen', 'coral'),
  print.mode=c("raw","percent"),
   cat.pos = c(-27, 165))
```

![](C:/Users/MARINA/Documents/MASTER/TFM/Pictures/reactome_positive_brca1_brca2.jpg)
The only positive pathway that is found in BRCA1 affected, is found in BRCA1 healthy. 



Negative pathways shared between BRCA1 healthy and BRCA1 affected:
```{r}

intersect(negative_NES_reactome_brca1.sa,negative_NES_reactome_brca1.af)

venn.diagram(
  x = list(negative_NES_reactome_brca1.sa, negative_NES_reactome_brca1.af),
  category.names = c("BRCA1.HEALTHY", "BRCA1.AFFECTED"),
  filename = 'reactome_negative_venn_diagramm_brca1_vs_brca1_50filt.png',
  output = TRUE,
  main = 'Negative BRCA1 Healthy vs Negative BRCA1 Affected',
  col = "transparent",
  fill = c('forestgreen', 'coral'),
  print.mode=c("raw","percent"),cat.pos = c(-27, 160))

```
![](C:/Users/MARINA/Documents/MASTER/TFM/Pictures/reactome_negative_BRCA1.jpg)

The 2 pathways found in BRCA1 affected are shared with BRCA1 healthy pathways. 


Positive BCRA1 healthy pathways that are negative in BCRA1 affected:
```{r}
intersect(positive_NES_reactome_brca1.sa,negative_NES_reactome_brca1.af)
venn.diagram(
  x = list(positive_NES_reactome_brca1.sa, negative_NES_reactome_brca1.af),
  category.names = c("BRCA1.HEALTHY", "BRCA1.AF"),
  filename = 'reactome_pos_neg_venn_diagramm_brca1sa_vs_brca1af_50filt.png',
  output = TRUE,
  main = 'Venn diagram BRCA1 Healthy vs BRCA1 Affected',
  col = "transparent",
  fill = c('forestgreen', 'coral'),
  print.mode=c("raw","percent"))
```

There are no positive BRCA1 healthy pathways that are shared with the negative BRCA1 affected pathways.

Negative BCRA1 healthy pathways that are positive in BCRA1 affected:
```{r}
intersect(negative_NES_reactome_brca1.sa,positive_NES_reactome_brca1.af)
venn.diagram(
  x = list(negative_NES_reactome_brca1.sa, positive_NES_reactome_brca1.af),
  category.names = c("BRCA1.HEALTHY", "BRCA1.AFFECTED"),
  filename = 'reactome_neg_pos_venn_diagramm_brca1sa_vs_brca1af_50filt.png',
  output = TRUE,
  main = 'Venn diagram BRCA1 Healthy vs BRCA1 Affected',
  col = "transparent",
  fill = c('forestgreen', 'coral'),
  print.mode=c("raw","percent"))
```

There are no negative BRCA1 healthy pathways shared with the positive of BRCA1 affected.


#### BRCA2.SA vs BRCA2.AF

Positive pathways shared between BRCA2 healthy and BRCA2 affected:
```{r}
intersect(positive_NES_reactome_brca2.sa,positive_NES_reactome_brca2.af)
venn.diagram(
  x = list(positive_NES_reactome_brca2.sa, positive_NES_reactome_brca2.af),
  category.names = c("BRCA2.HEALTHY", "BRCA2.AFFECTED"),
  filename = 'reactome_positive_venn_diagramm_brca2_vs_brca2_50filt.png',
  output = TRUE,
  main = 'Venn diagram BRCA2 Healthy vs BRCA2 Affected',
  col = "transparent",
  fill = c('forestgreen', 'coral'),
  print.mode=c("raw","percent"),cat.pos = c(-27,100),cat.dist= c(0.02,-0.05))
```

![](C:/Users/MARINA/Documents/MASTER/TFM/Pictures/reactome_positive_brca2.jpg)


Negative pathways shared between BRCA2 healthy and BRCA2 affected:
```{r}
intersect(negative_NES_reactome_brca2.sa,negative_NES_reactome_brca2.af)
venn.diagram(
  x = list(negative_NES_reactome_brca2.sa, negative_NES_reactome_brca2.af),
  category.names = c("BRCA2.HEALTHY", "BRCA2.AFFECTED"),
  filename = 'reactome_negative_venn_diagramm_brca2_vs_brca2_50filt.png',
  output = TRUE,
  main = 'Venn diagram BRCA2 Healthy vs BRCA2 Affected',
  col = "transparent",
  fill = c('forestgreen', 'coral'),
  print.mode=c("raw","percent"),cat.pos = c(-27,160),cat.dist= c(0.02,-0.05))
```
![](C:/Users/MARINA/Documents/MASTER/TFM/Pictures/reactome_negative_BRCA2.jpg)


Positive BRCA2 healthy pathways that are negative in BRCA2 affected:
```{r}
intersect(positive_NES_reactome_brca2.sa,negative_NES_reactome_brca2.af)

venn.diagram(
  x = list(positive_NES_reactome_brca2.sa, negative_NES_reactome_brca2.af),
  category.names = c("BRCA2.HEALTHY", "BRCA2.AFFECTED"),
  filename = 'reactome_pos_neg_venn_diagramm_brca2_vs_brca2_50filt.png',
  output = TRUE,
  main = 'Positive BRCA2 Healthy vs Negative BRCA2 Affected',
  col = "transparent",
  fill = c('forestgreen', 'coral'),
  print.mode=c("raw","percent"),cat.pos=c(30,-30),cat.dist=c(0,0))
```

Negative BRCA2 healthy pathways that are positive in BRCA2 affected:
```{r}
intersect(negative_NES_reactome_brca2.sa,positive_NES_reactome_brca2.af)
venn.diagram(
  x = list(negative_NES_reactome_brca2.sa, positive_NES_reactome_brca2.af),
  category.names = c("BRCA2.HEALTHY", "BRCA2.AFFECTED"),
  filename = 'reactome_neg_pos_venn_diagramm_brca2sa_vs_brca2af_50filt.png',
  output = TRUE,
  main = 'Negative BRCA2 Healthy vs Positive BRCA2 Affected',
  col = "transparent",
  fill = c('forestgreen', 'coral'),
  print.mode=c("raw","percent"),cat.pos = c(-27, 170))
```


